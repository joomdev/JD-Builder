(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["UIkit"] = factory();
	else
		root["UIkit"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/uikit.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack://UIkit/./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6â€“8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack://UIkit/./node_modules/setimmediate/setImmediate.js?");

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ \"./node_modules/setimmediate/setImmediate.js\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://UIkit/./node_modules/timers-browserify/main.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack://UIkit/(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/uikit.js":
/*!***********************************!*\
  !*** ./src/uikit.js + 74 modules ***!
  \***********************************/
/*! exports provided: default */
/*! ModuleConcatenation bailout: Cannot concat with ./src/util/lang.js because of ./src/util/promise.js */
/*! ModuleConcatenation bailout: Cannot concat with ./src/util/promise.js (<- Module uses injected variables (setImmediate)) */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nvar util_namespaceObject = {};\n__webpack_require__.r(util_namespaceObject);\n__webpack_require__.d(util_namespaceObject, \"transition\", function() { return animation_transition; });\n__webpack_require__.d(util_namespaceObject, \"Transition\", function() { return Transition; });\n__webpack_require__.d(util_namespaceObject, \"animate\", function() { return animation_animate; });\n__webpack_require__.d(util_namespaceObject, \"Animation\", function() { return Animation; });\n__webpack_require__.d(util_namespaceObject, \"attr\", function() { return attr_attr; });\n__webpack_require__.d(util_namespaceObject, \"hasAttr\", function() { return hasAttr; });\n__webpack_require__.d(util_namespaceObject, \"removeAttr\", function() { return removeAttr; });\n__webpack_require__.d(util_namespaceObject, \"data\", function() { return attr_data; });\n__webpack_require__.d(util_namespaceObject, \"addClass\", function() { return addClass; });\n__webpack_require__.d(util_namespaceObject, \"removeClass\", function() { return removeClass; });\n__webpack_require__.d(util_namespaceObject, \"removeClasses\", function() { return removeClasses; });\n__webpack_require__.d(util_namespaceObject, \"replaceClass\", function() { return replaceClass; });\n__webpack_require__.d(util_namespaceObject, \"hasClass\", function() { return hasClass; });\n__webpack_require__.d(util_namespaceObject, \"toggleClass\", function() { return toggleClass; });\n__webpack_require__.d(util_namespaceObject, \"positionAt\", function() { return positionAt; });\n__webpack_require__.d(util_namespaceObject, \"offset\", function() { return dimensions_offset; });\n__webpack_require__.d(util_namespaceObject, \"position\", function() { return dimensions_position; });\n__webpack_require__.d(util_namespaceObject, \"height\", function() { return dimensions_height; });\n__webpack_require__.d(util_namespaceObject, \"width\", function() { return dimensions_width; });\n__webpack_require__.d(util_namespaceObject, \"boxModelAdjust\", function() { return boxModelAdjust; });\n__webpack_require__.d(util_namespaceObject, \"flipPosition\", function() { return flipPosition; });\n__webpack_require__.d(util_namespaceObject, \"isInView\", function() { return isInView; });\n__webpack_require__.d(util_namespaceObject, \"scrolledOver\", function() { return scrolledOver; });\n__webpack_require__.d(util_namespaceObject, \"scrollTop\", function() { return scrollTop; });\n__webpack_require__.d(util_namespaceObject, \"offsetPosition\", function() { return offsetPosition; });\n__webpack_require__.d(util_namespaceObject, \"toPx\", function() { return toPx; });\n__webpack_require__.d(util_namespaceObject, \"ready\", function() { return ready; });\n__webpack_require__.d(util_namespaceObject, \"index\", function() { return dom_index; });\n__webpack_require__.d(util_namespaceObject, \"getIndex\", function() { return getIndex; });\n__webpack_require__.d(util_namespaceObject, \"empty\", function() { return empty; });\n__webpack_require__.d(util_namespaceObject, \"html\", function() { return dom_html; });\n__webpack_require__.d(util_namespaceObject, \"prepend\", function() { return prepend; });\n__webpack_require__.d(util_namespaceObject, \"append\", function() { return append; });\n__webpack_require__.d(util_namespaceObject, \"before\", function() { return before; });\n__webpack_require__.d(util_namespaceObject, \"after\", function() { return after; });\n__webpack_require__.d(util_namespaceObject, \"remove\", function() { return remove; });\n__webpack_require__.d(util_namespaceObject, \"wrapAll\", function() { return wrapAll; });\n__webpack_require__.d(util_namespaceObject, \"wrapInner\", function() { return wrapInner; });\n__webpack_require__.d(util_namespaceObject, \"unwrap\", function() { return unwrap; });\n__webpack_require__.d(util_namespaceObject, \"fragment\", function() { return fragment; });\n__webpack_require__.d(util_namespaceObject, \"apply\", function() { return dom_apply; });\n__webpack_require__.d(util_namespaceObject, \"$\", function() { return dom_$; });\n__webpack_require__.d(util_namespaceObject, \"$$\", function() { return $$; });\n__webpack_require__.d(util_namespaceObject, \"isIE\", function() { return isIE; });\n__webpack_require__.d(util_namespaceObject, \"isRtl\", function() { return isRtl; });\n__webpack_require__.d(util_namespaceObject, \"hasTouch\", function() { return hasTouch; });\n__webpack_require__.d(util_namespaceObject, \"pointerDown\", function() { return pointerDown; });\n__webpack_require__.d(util_namespaceObject, \"pointerMove\", function() { return pointerMove; });\n__webpack_require__.d(util_namespaceObject, \"pointerUp\", function() { return pointerUp; });\n__webpack_require__.d(util_namespaceObject, \"pointerEnter\", function() { return pointerEnter; });\n__webpack_require__.d(util_namespaceObject, \"pointerLeave\", function() { return pointerLeave; });\n__webpack_require__.d(util_namespaceObject, \"pointerCancel\", function() { return pointerCancel; });\n__webpack_require__.d(util_namespaceObject, \"on\", function() { return on; });\n__webpack_require__.d(util_namespaceObject, \"off\", function() { return event_off; });\n__webpack_require__.d(util_namespaceObject, \"once\", function() { return once; });\n__webpack_require__.d(util_namespaceObject, \"trigger\", function() { return trigger; });\n__webpack_require__.d(util_namespaceObject, \"createEvent\", function() { return createEvent; });\n__webpack_require__.d(util_namespaceObject, \"toEventTargets\", function() { return toEventTargets; });\n__webpack_require__.d(util_namespaceObject, \"isTouch\", function() { return isTouch; });\n__webpack_require__.d(util_namespaceObject, \"getEventPos\", function() { return getEventPos; });\n__webpack_require__.d(util_namespaceObject, \"fastdom\", function() { return fastdom; });\n__webpack_require__.d(util_namespaceObject, \"isVoidElement\", function() { return isVoidElement; });\n__webpack_require__.d(util_namespaceObject, \"isVisible\", function() { return isVisible; });\n__webpack_require__.d(util_namespaceObject, \"selInput\", function() { return selInput; });\n__webpack_require__.d(util_namespaceObject, \"isInput\", function() { return isInput; });\n__webpack_require__.d(util_namespaceObject, \"filter\", function() { return filter_filter; });\n__webpack_require__.d(util_namespaceObject, \"within\", function() { return within; });\n__webpack_require__.d(util_namespaceObject, \"bind\", function() { return lang[\"bind\"]; });\n__webpack_require__.d(util_namespaceObject, \"hasOwn\", function() { return lang[\"hasOwn\"]; });\n__webpack_require__.d(util_namespaceObject, \"hyphenate\", function() { return lang[\"hyphenate\"]; });\n__webpack_require__.d(util_namespaceObject, \"camelize\", function() { return lang[\"camelize\"]; });\n__webpack_require__.d(util_namespaceObject, \"ucfirst\", function() { return lang[\"ucfirst\"]; });\n__webpack_require__.d(util_namespaceObject, \"startsWith\", function() { return lang[\"startsWith\"]; });\n__webpack_require__.d(util_namespaceObject, \"endsWith\", function() { return lang[\"endsWith\"]; });\n__webpack_require__.d(util_namespaceObject, \"includes\", function() { return lang[\"includes\"]; });\n__webpack_require__.d(util_namespaceObject, \"findIndex\", function() { return lang[\"findIndex\"]; });\n__webpack_require__.d(util_namespaceObject, \"isArray\", function() { return lang[\"isArray\"]; });\n__webpack_require__.d(util_namespaceObject, \"isFunction\", function() { return lang[\"isFunction\"]; });\n__webpack_require__.d(util_namespaceObject, \"isObject\", function() { return lang[\"isObject\"]; });\n__webpack_require__.d(util_namespaceObject, \"isPlainObject\", function() { return lang[\"isPlainObject\"]; });\n__webpack_require__.d(util_namespaceObject, \"isWindow\", function() { return lang[\"isWindow\"]; });\n__webpack_require__.d(util_namespaceObject, \"isDocument\", function() { return lang[\"isDocument\"]; });\n__webpack_require__.d(util_namespaceObject, \"isJQuery\", function() { return lang[\"isJQuery\"]; });\n__webpack_require__.d(util_namespaceObject, \"isNode\", function() { return lang[\"isNode\"]; });\n__webpack_require__.d(util_namespaceObject, \"isNodeCollection\", function() { return lang[\"isNodeCollection\"]; });\n__webpack_require__.d(util_namespaceObject, \"isBoolean\", function() { return lang[\"isBoolean\"]; });\n__webpack_require__.d(util_namespaceObject, \"isString\", function() { return lang[\"isString\"]; });\n__webpack_require__.d(util_namespaceObject, \"isNumber\", function() { return lang[\"isNumber\"]; });\n__webpack_require__.d(util_namespaceObject, \"isNumeric\", function() { return lang[\"isNumeric\"]; });\n__webpack_require__.d(util_namespaceObject, \"isEmpty\", function() { return lang[\"isEmpty\"]; });\n__webpack_require__.d(util_namespaceObject, \"isUndefined\", function() { return lang[\"isUndefined\"]; });\n__webpack_require__.d(util_namespaceObject, \"toBoolean\", function() { return lang[\"toBoolean\"]; });\n__webpack_require__.d(util_namespaceObject, \"toNumber\", function() { return lang[\"toNumber\"]; });\n__webpack_require__.d(util_namespaceObject, \"toFloat\", function() { return lang[\"toFloat\"]; });\n__webpack_require__.d(util_namespaceObject, \"toNode\", function() { return lang[\"toNode\"]; });\n__webpack_require__.d(util_namespaceObject, \"toNodes\", function() { return lang[\"toNodes\"]; });\n__webpack_require__.d(util_namespaceObject, \"toList\", function() { return lang[\"toList\"]; });\n__webpack_require__.d(util_namespaceObject, \"toMs\", function() { return lang[\"toMs\"]; });\n__webpack_require__.d(util_namespaceObject, \"isEqual\", function() { return lang[\"isEqual\"]; });\n__webpack_require__.d(util_namespaceObject, \"swap\", function() { return lang[\"swap\"]; });\n__webpack_require__.d(util_namespaceObject, \"assign\", function() { return lang[\"assign\"]; });\n__webpack_require__.d(util_namespaceObject, \"each\", function() { return lang[\"each\"]; });\n__webpack_require__.d(util_namespaceObject, \"sortBy\", function() { return lang[\"sortBy\"]; });\n__webpack_require__.d(util_namespaceObject, \"uniqueBy\", function() { return lang[\"uniqueBy\"]; });\n__webpack_require__.d(util_namespaceObject, \"clamp\", function() { return lang[\"clamp\"]; });\n__webpack_require__.d(util_namespaceObject, \"noop\", function() { return lang[\"noop\"]; });\n__webpack_require__.d(util_namespaceObject, \"intersectRect\", function() { return lang[\"intersectRect\"]; });\n__webpack_require__.d(util_namespaceObject, \"pointInRect\", function() { return lang[\"pointInRect\"]; });\n__webpack_require__.d(util_namespaceObject, \"Dimensions\", function() { return lang[\"Dimensions\"]; });\n__webpack_require__.d(util_namespaceObject, \"mergeOptions\", function() { return mergeOptions; });\n__webpack_require__.d(util_namespaceObject, \"parseOptions\", function() { return parseOptions; });\n__webpack_require__.d(util_namespaceObject, \"Promise\", function() { return util_promise[\"Promise\"]; });\n__webpack_require__.d(util_namespaceObject, \"Deferred\", function() { return util_promise[\"Deferred\"]; });\n__webpack_require__.d(util_namespaceObject, \"query\", function() { return query; });\n__webpack_require__.d(util_namespaceObject, \"queryAll\", function() { return queryAll; });\n__webpack_require__.d(util_namespaceObject, \"find\", function() { return find; });\n__webpack_require__.d(util_namespaceObject, \"findAll\", function() { return findAll; });\n__webpack_require__.d(util_namespaceObject, \"matches\", function() { return selector_matches; });\n__webpack_require__.d(util_namespaceObject, \"closest\", function() { return closest; });\n__webpack_require__.d(util_namespaceObject, \"parents\", function() { return parents; });\n__webpack_require__.d(util_namespaceObject, \"escape\", function() { return selector_escape; });\n__webpack_require__.d(util_namespaceObject, \"css\", function() { return style_css; });\n__webpack_require__.d(util_namespaceObject, \"getStyles\", function() { return getStyles; });\n__webpack_require__.d(util_namespaceObject, \"getStyle\", function() { return getStyle; });\n__webpack_require__.d(util_namespaceObject, \"getCssVar\", function() { return getCssVar; });\n__webpack_require__.d(util_namespaceObject, \"propName\", function() { return style_propName; });\n__webpack_require__.d(util_namespaceObject, \"getImage\", function() { return getImage; });\n__webpack_require__.d(util_namespaceObject, \"uniqueid\", function() { return uniqueid; });\n\n// EXTERNAL MODULE: ./src/util/lang.js\nvar lang = __webpack_require__(\"./src/util/lang.js\");\n\n// CONCATENATED MODULE: ./src/util/attr.js\n\n\nfunction attr_attr(element, name, value) {\n\n    if (Object(lang[\"isObject\"])(name)) {\n        for (const key in name) {\n            attr_attr(element, key, name[key]);\n        }\n        return;\n    }\n\n    if (Object(lang[\"isUndefined\"])(value)) {\n        element = Object(lang[\"toNode\"])(element);\n        return element && element.getAttribute(name);\n    } else {\n        Object(lang[\"toNodes\"])(element).forEach(element => {\n\n            if (Object(lang[\"isFunction\"])(value)) {\n                value = value.call(element, attr_attr(element, name));\n            }\n\n            if (value === null) {\n                removeAttr(element, name);\n            } else {\n                element.setAttribute(name, value);\n            }\n        });\n    }\n\n}\n\nfunction hasAttr(element, name) {\n    return Object(lang[\"toNodes\"])(element).some(element => element.hasAttribute(name));\n}\n\nfunction removeAttr(element, name) {\n    element = Object(lang[\"toNodes\"])(element);\n    name.split(' ').forEach(name =>\n        element.forEach(element =>\n            element.hasAttribute(name) && element.removeAttribute(name)\n        )\n    );\n}\n\nfunction attr_data(element, attribute) {\n    for (let i = 0, attrs = [attribute, `data-${attribute}`]; i < attrs.length; i++) {\n        if (hasAttr(element, attrs[i])) {\n            return attr_attr(element, attrs[i]);\n        }\n    }\n}\n\n// EXTERNAL MODULE: ./src/util/promise.js\nvar util_promise = __webpack_require__(\"./src/util/promise.js\");\n\n// CONCATENATED MODULE: ./src/util/selector.js\n\n\n\nfunction query(selector, context) {\n    return Object(lang[\"toNode\"])(selector) || find(selector, getContext(selector, context));\n}\n\nfunction queryAll(selector, context) {\n    const nodes = Object(lang[\"toNodes\"])(selector);\n    return nodes.length && nodes || findAll(selector, getContext(selector, context));\n}\n\nfunction getContext(selector, context = document) {\n    return isContextSelector(selector) || Object(lang[\"isDocument\"])(context)\n        ? context\n        : context.ownerDocument;\n}\n\nfunction find(selector, context) {\n    return Object(lang[\"toNode\"])(_query(selector, context, 'querySelector'));\n}\n\nfunction findAll(selector, context) {\n    return Object(lang[\"toNodes\"])(_query(selector, context, 'querySelectorAll'));\n}\n\nfunction _query(selector, context = document, queryFn) {\n\n    if (!selector || !Object(lang[\"isString\"])(selector)) {\n        return null;\n    }\n\n    selector = selector.replace(contextSanitizeRe, '$1 *');\n\n    let removes;\n\n    if (isContextSelector(selector)) {\n\n        removes = [];\n\n        selector = splitSelector(selector).map((selector, i) => {\n\n            let ctx = context;\n\n            if (selector[0] === '!') {\n\n                const selectors = selector.substr(1).trim().split(' ');\n                ctx = closest(context.parentNode, selectors[0]);\n                selector = selectors.slice(1).join(' ').trim();\n\n            }\n\n            if (selector[0] === '-') {\n\n                const selectors = selector.substr(1).trim().split(' ');\n                const prev = (ctx || context).previousElementSibling;\n                ctx = selector_matches(prev, selector.substr(1)) ? prev : null;\n                selector = selectors.slice(1).join(' ');\n\n            }\n\n            if (!ctx) {\n                return null;\n            }\n\n            if (!ctx.id) {\n                ctx.id = `jdb-${Date.now()}${i}`;\n                removes.push(() => removeAttr(ctx, 'id'));\n            }\n\n            return `#${selector_escape(ctx.id)} ${selector}`;\n\n        }).filter(Boolean).join(',');\n\n        context = document;\n\n    }\n\n    try {\n\n        return context[queryFn](selector);\n\n    } catch (e) {\n\n        return null;\n\n    } finally {\n\n        removes && removes.forEach(remove => remove());\n\n    }\n\n}\n\nconst contextSelectorRe = /(^|[^\\\\],)\\s*[!>+~-]/;\nconst contextSanitizeRe = /([!>+~-])(?=\\s+[!>+~-]|\\s*$)/g;\n\nfunction isContextSelector(selector) {\n    return Object(lang[\"isString\"])(selector) && selector.match(contextSelectorRe);\n}\n\nconst selectorRe = /.*?[^\\\\](?:,|$)/g;\n\nfunction splitSelector(selector) {\n    return selector.match(selectorRe).map(selector => selector.replace(/,$/, '').trim());\n}\n\nconst elProto = Element.prototype;\nconst matchesFn = elProto.matches || elProto.webkitMatchesSelector || elProto.msMatchesSelector;\n\nfunction selector_matches(element, selector) {\n    return Object(lang[\"toNodes\"])(element).some(element => matchesFn.call(element, selector));\n}\n\nconst closestFn = elProto.closest || function (selector) {\n    let ancestor = this;\n\n    do {\n\n        if (selector_matches(ancestor, selector)) {\n            return ancestor;\n        }\n\n        ancestor = ancestor.parentNode;\n\n    } while (ancestor && ancestor.nodeType === 1);\n};\n\nfunction closest(element, selector) {\n\n    if (Object(lang[\"startsWith\"])(selector, '>')) {\n        selector = selector.slice(1);\n    }\n\n    return Object(lang[\"isNode\"])(element)\n        ? element.parentNode && closestFn.call(element, selector)\n        : Object(lang[\"toNodes\"])(element).map(element => closest(element, selector)).filter(Boolean);\n}\n\nfunction parents(element, selector) {\n    const elements = [];\n    let parent = Object(lang[\"toNode\"])(element).parentNode;\n\n    while (parent && parent.nodeType === 1) {\n\n        if (selector_matches(parent, selector)) {\n            elements.push(parent);\n        }\n\n        parent = parent.parentNode;\n    }\n\n    return elements;\n}\n\nconst escapeFn = window.CSS && CSS.escape || function (css) { return css.replace(/([^\\x7f-\\uFFFF\\w-])/g, match => `\\\\${match}`); };\nfunction selector_escape(css) {\n    return Object(lang[\"isString\"])(css) ? escapeFn.call(null, css) : '';\n}\n\n// CONCATENATED MODULE: ./src/util/filter.js\n\n\n\nconst voidElements = {\n    area: true,\n    base: true,\n    br: true,\n    col: true,\n    embed: true,\n    hr: true,\n    img: true,\n    input: true,\n    keygen: true,\n    link: true,\n    menuitem: true,\n    meta: true,\n    param: true,\n    source: true,\n    track: true,\n    wbr: true\n};\nfunction isVoidElement(element) {\n    return Object(lang[\"toNodes\"])(element).some(element => voidElements[element.tagName.toLowerCase()]);\n}\n\nfunction isVisible(element) {\n    return Object(lang[\"toNodes\"])(element).some(element => element.offsetWidth || element.offsetHeight || element.getClientRects().length);\n}\n\nconst selInput = 'input,select,textarea,button';\nfunction isInput(element) {\n    return Object(lang[\"toNodes\"])(element).some(element => selector_matches(element, selInput));\n}\n\nfunction filter_filter(element, selector) {\n    return Object(lang[\"toNodes\"])(element).filter(element => selector_matches(element, selector));\n}\n\nfunction within(element, selector) {\n    return !Object(lang[\"isString\"])(selector)\n        ? element === selector || (Object(lang[\"isDocument\"])(selector)\n            ? selector.documentElement\n            : Object(lang[\"toNode\"])(selector)).contains(Object(lang[\"toNode\"])(element)) // IE 11 document does not implement contains\n        : selector_matches(element, selector) || closest(element, selector);\n}\n\n// CONCATENATED MODULE: ./src/util/event.js\n\n\n\n\nfunction on(...args) {\n\n    let [targets, type, selector, listener, useCapture] = getArgs(args);\n\n    targets = toEventTargets(targets);\n\n    if (selector) {\n        listener = event_delegate(targets, selector, listener);\n    }\n\n    if (listener.length > 1) {\n        listener = event_detail(listener);\n    }\n\n    type.split(' ').forEach(type =>\n        targets.forEach(target =>\n            target.addEventListener(type, listener, useCapture)\n        )\n    );\n    return () => event_off(targets, type, listener, useCapture);\n}\n\nfunction event_off(targets, type, listener, useCapture = false) {\n    targets = toEventTargets(targets);\n    type.split(' ').forEach(type =>\n        targets.forEach(target =>\n            target.removeEventListener(type, listener, useCapture)\n        )\n    );\n}\n\nfunction once(...args) {\n\n    const [element, type, selector, listener, useCapture, condition] = getArgs(args);\n    const off = on(element, type, selector, e => {\n        const result = !condition || condition(e);\n        if (result) {\n            off();\n            listener(e, result);\n        }\n    }, useCapture);\n\n    return off;\n}\n\nfunction trigger(targets, event, detail) {\n    return toEventTargets(targets).reduce((notCanceled, target) =>\n        notCanceled && target.dispatchEvent(createEvent(event, true, true, detail))\n        , true);\n}\n\nfunction createEvent(e, bubbles = true, cancelable = false, detail) {\n    if (Object(lang[\"isString\"])(e)) {\n        const event = document.createEvent('CustomEvent'); // IE 11\n        event.initCustomEvent(e, bubbles, cancelable, detail);\n        e = event;\n    }\n\n    return e;\n}\n\nfunction getArgs(args) {\n    if (Object(lang[\"isFunction\"])(args[2])) {\n        args.splice(2, 0, false);\n    }\n    return args;\n}\n\nfunction event_delegate(delegates, selector, listener) {\n    return e => {\n\n        delegates.forEach(delegate => {\n\n            const current = selector[0] === '>'\n                ? findAll(selector, delegate).reverse().filter(element => within(e.target, element))[0]\n                : closest(e.target, selector);\n\n            if (current) {\n                e.delegate = delegate;\n                e.current = current;\n\n                listener.call(this, e);\n            }\n\n        });\n\n    };\n}\n\nfunction event_detail(listener) {\n    return e => Object(lang[\"isArray\"])(e.detail) ? listener(...[e].concat(e.detail)) : listener(e);\n}\n\nfunction isEventTarget(target) {\n    return target && 'addEventListener' in target;\n}\n\nfunction toEventTarget(target) {\n    return isEventTarget(target) ? target : Object(lang[\"toNode\"])(target);\n}\n\nfunction toEventTargets(target) {\n    return Object(lang[\"isArray\"])(target)\n            ? target.map(toEventTarget).filter(Boolean)\n            : Object(lang[\"isString\"])(target)\n                ? findAll(target)\n                : isEventTarget(target)\n                    ? [target]\n                    : Object(lang[\"toNodes\"])(target);\n}\n\nfunction isTouch(e) {\n    return e.pointerType === 'touch' || e.touches;\n}\n\nfunction getEventPos(e, prop = 'client') {\n    const {touches, changedTouches} = e;\n    const {[`${prop}X`]: x, [`${prop}Y`]: y} = touches && touches[0] || changedTouches && changedTouches[0] || e;\n\n    return {x, y};\n}\n\n// CONCATENATED MODULE: ./src/util/env.js\n/* global DocumentTouch */\n\n\nconst isIE = /msie|trident/i.test(window.navigator.userAgent);\nconst isRtl = attr_attr(document.documentElement, 'dir') === 'rtl';\n\nconst hasTouchEvents = 'ontouchstart' in window;\nconst hasPointerEvents = window.PointerEvent;\nconst hasTouch = hasTouchEvents\n    || window.DocumentTouch && document instanceof DocumentTouch\n    || navigator.maxTouchPoints; // IE >=11\n\nconst pointerDown = hasPointerEvents ? 'pointerdown' : hasTouchEvents ? 'touchstart' : 'mousedown';\nconst pointerMove = hasPointerEvents ? 'pointermove' : hasTouchEvents ? 'touchmove' : 'mousemove';\nconst pointerUp = hasPointerEvents ? 'pointerup' : hasTouchEvents ? 'touchend' : 'mouseup';\nconst pointerEnter = hasPointerEvents ? 'pointerenter' : hasTouchEvents ? '' : 'mouseenter';\nconst pointerLeave = hasPointerEvents ? 'pointerleave' : hasTouchEvents ? '' : 'mouseleave';\nconst pointerCancel = hasPointerEvents ? 'pointercancel' : 'touchcancel';\n\n\n// CONCATENATED MODULE: ./src/util/dom.js\n\n\n\n\nfunction ready(fn) {\n\n    if (document.readyState !== 'loading') {\n        fn();\n        return;\n    }\n\n    const unbind = on(document, 'DOMContentLoaded', function () {\n        unbind();\n        fn();\n    });\n}\n\nfunction dom_index(element, ref) {\n    return ref\n        ? Object(lang[\"toNodes\"])(element).indexOf(Object(lang[\"toNode\"])(ref))\n        : Object(lang[\"toNodes\"])((element = Object(lang[\"toNode\"])(element)) && element.parentNode.children).indexOf(element);\n}\n\nfunction getIndex(i, elements, current = 0, finite = false) {\n\n    elements = Object(lang[\"toNodes\"])(elements);\n\n    const {length} = elements;\n\n    i = Object(lang[\"isNumeric\"])(i)\n        ? Object(lang[\"toNumber\"])(i)\n        : i === 'next'\n            ? current + 1\n            : i === 'previous'\n                ? current - 1\n                : dom_index(elements, i);\n\n    if (finite) {\n        return Object(lang[\"clamp\"])(i, 0, length - 1);\n    }\n\n    i %= length;\n\n    return i < 0 ? i + length : i;\n}\n\nfunction empty(element) {\n    element = dom_$(element);\n    element.innerHTML = '';\n    return element;\n}\n\nfunction dom_html(parent, html) {\n    parent = dom_$(parent);\n    return Object(lang[\"isUndefined\"])(html)\n        ? parent.innerHTML\n        : append(parent.hasChildNodes() ? empty(parent) : parent, html);\n}\n\nfunction prepend(parent, element) {\n\n    parent = dom_$(parent);\n\n    if (!parent.hasChildNodes()) {\n        return append(parent, element);\n    } else {\n        return insertNodes(element, element => parent.insertBefore(element, parent.firstChild));\n    }\n}\n\nfunction append(parent, element) {\n    parent = dom_$(parent);\n    return insertNodes(element, element => parent.appendChild(element));\n}\n\nfunction before(ref, element) {\n    ref = dom_$(ref);\n    return insertNodes(element, element => ref.parentNode.insertBefore(element, ref));\n}\n\nfunction after(ref, element) {\n    ref = dom_$(ref);\n    return insertNodes(element, element => ref.nextSibling\n        ? before(ref.nextSibling, element)\n        : append(ref.parentNode, element)\n    );\n}\n\nfunction insertNodes(element, fn) {\n    element = Object(lang[\"isString\"])(element) ? fragment(element) : element;\n    return element\n        ? 'length' in element\n            ? Object(lang[\"toNodes\"])(element).map(fn)\n            : fn(element)\n        : null;\n}\n\nfunction remove(element) {\n    Object(lang[\"toNodes\"])(element).map(element => element.parentNode && element.parentNode.removeChild(element));\n}\n\nfunction wrapAll(element, structure) {\n\n    structure = Object(lang[\"toNode\"])(before(element, structure));\n\n    while (structure.firstChild) {\n        structure = structure.firstChild;\n    }\n\n    append(structure, element);\n\n    return structure;\n}\n\nfunction wrapInner(element, structure) {\n    return Object(lang[\"toNodes\"])(Object(lang[\"toNodes\"])(element).map(element =>\n        element.hasChildNodes ? wrapAll(Object(lang[\"toNodes\"])(element.childNodes), structure) : append(element, structure)\n    ));\n}\n\nfunction unwrap(element) {\n    Object(lang[\"toNodes\"])(element)\n        .map(element => element.parentNode)\n        .filter((value, index, self) => self.indexOf(value) === index)\n        .forEach(parent => {\n            before(parent, parent.childNodes);\n            remove(parent);\n        });\n}\n\nconst fragmentRe = /^\\s*<(\\w+|!)[^>]*>/;\nconst singleTagRe = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>)?$/;\n\nfunction fragment(html) {\n\n    const matches = singleTagRe.exec(html);\n    if (matches) {\n        return document.createElement(matches[1]);\n    }\n\n    const container = document.createElement('div');\n    if (fragmentRe.test(html)) {\n        container.insertAdjacentHTML('beforeend', html.trim());\n    } else {\n        container.textContent = html;\n    }\n\n    return container.childNodes.length > 1 ? Object(lang[\"toNodes\"])(container.childNodes) : container.firstChild;\n\n}\n\nfunction dom_apply(node, fn) {\n\n    if (!node || node.nodeType !== 1) {\n        return;\n    }\n\n    fn(node);\n    node = node.firstElementChild;\n    while (node) {\n        dom_apply(node, fn);\n        node = node.nextElementSibling;\n    }\n}\n\nfunction dom_$(selector, context) {\n    return !Object(lang[\"isString\"])(selector)\n        ? Object(lang[\"toNode\"])(selector)\n        : isHtml(selector)\n            ? Object(lang[\"toNode\"])(fragment(selector))\n            : find(selector, context);\n}\n\nfunction $$(selector, context) {\n    return !Object(lang[\"isString\"])(selector)\n        ? Object(lang[\"toNodes\"])(selector)\n        : isHtml(selector)\n            ? Object(lang[\"toNodes\"])(fragment(selector))\n            : findAll(selector, context);\n}\n\nfunction isHtml(str) {\n    return str[0] === '<' || str.match(/^\\s*</);\n}\n\n\n// CONCATENATED MODULE: ./src/util/class.js\n\n\n\nfunction addClass(element, ...args) {\n    class_apply(element, args, 'add');\n}\n\nfunction removeClass(element, ...args) {\n    class_apply(element, args, 'remove');\n}\n\nfunction removeClasses(element, cls) {\n    attr_attr(element, 'class', value => (value || '').replace(new RegExp(`\\\\b${cls}\\\\b`, 'g'), ''));\n}\n\nfunction replaceClass(element, ...args) {\n    args[0] && removeClass(element, args[0]);\n    args[1] && addClass(element, args[1]);\n}\n\nfunction hasClass(element, cls) {\n    return cls && Object(lang[\"toNodes\"])(element).some(element => element.classList.contains(cls.split(' ')[0]));\n}\n\nfunction toggleClass(element, ...args) {\n\n    if (!args.length) {\n        return;\n    }\n\n    args = class_getArgs(args);\n\n    const force = !Object(lang[\"isString\"])(args[args.length - 1]) ? args.pop() : []; // in iOS 9.3 force === undefined evaluates to false\n\n    args = args.filter(Boolean);\n\n    Object(lang[\"toNodes\"])(element).forEach(({classList}) => {\n        for (let i = 0; i < args.length; i++) {\n            supports.Force\n                ? classList.toggle(...[args[i]].concat(force))\n                : (classList[(!Object(lang[\"isUndefined\"])(force) ? force : !classList.contains(args[i])) ? 'add' : 'remove'](args[i]));\n        }\n    });\n\n}\n\nfunction class_apply(element, args, fn) {\n    args = class_getArgs(args).filter(Boolean);\n\n    args.length && Object(lang[\"toNodes\"])(element).forEach(({classList}) => {\n        supports.Multiple\n            ? classList[fn](...args)\n            : args.forEach(cls => classList[fn](cls));\n    });\n}\n\nfunction class_getArgs(args) {\n    return args.reduce((args, arg) =>\n        args.concat.call(args, Object(lang[\"isString\"])(arg) && Object(lang[\"includes\"])(arg, ' ') ? arg.trim().split(' ') : arg)\n        , []);\n}\n\n// IE 11\nconst supports = {\n\n    get Multiple() {\n        return this.get('_multiple');\n    },\n\n    get Force() {\n        return this.get('_force');\n    },\n\n    get(key) {\n\n        if (!Object(lang[\"hasOwn\"])(this, key)) {\n            const {classList} = document.createElement('_');\n            classList.add('a', 'b');\n            classList.toggle('c', false);\n            this._multiple = classList.contains('b');\n            this._force = !classList.contains('c');\n        }\n\n        return this[key];\n    }\n\n};\n\n// CONCATENATED MODULE: ./src/util/style.js\n\n\n\n\n\nconst cssNumber = {\n   'animation-iteration-count': true,\n   'column-count': true,\n   'fill-opacity': true,\n   'flex-grow': true,\n   'flex-shrink': true,\n   'font-weight': true,\n   'line-height': true,\n   'opacity': true,\n   'order': true,\n   'orphans': true,\n   'stroke-dasharray': true,\n   'stroke-dashoffset': true,\n   'widows': true,\n   'z-index': true,\n   'zoom': true\n};\n\nfunction style_css(element, property, value) {\n\n   return Object(lang[\"toNodes\"])(element).map(element => {\n\n      if (Object(lang[\"isString\"])(property)) {\n\n         property = style_propName(property);\n\n         if (Object(lang[\"isUndefined\"])(value)) {\n            return getStyle(element, property);\n         } else if (!value && !Object(lang[\"isNumber\"])(value)) {\n            element.style.removeProperty(property);\n         } else {\n            element.style[property] = Object(lang[\"isNumeric\"])(value) && !cssNumber[property] ? `${value}px` : value;\n         }\n\n      } else if (Object(lang[\"isArray\"])(property)) {\n\n         const styles = getStyles(element);\n\n         return property.reduce((props, property) => {\n            props[property] = styles[style_propName(property)];\n            return props;\n         }, {});\n\n      } else if (Object(lang[\"isObject\"])(property)) {\n         Object(lang[\"each\"])(property, (value, property) => style_css(element, property, value));\n      }\n\n      return element;\n\n   })[0];\n\n}\n\nfunction getStyles(element, pseudoElt) {\n   element = Object(lang[\"toNode\"])(element);\n   return element.ownerDocument.defaultView.getComputedStyle(element, pseudoElt);\n}\n\nfunction getStyle(element, property, pseudoElt) {\n   return getStyles(element, pseudoElt)[property];\n}\n\nconst vars = {};\n\nfunction getCssVar(name) {\n\n   const docEl = document.documentElement;\n\n   if (!isIE) {\n      return getStyles(docEl).getPropertyValue(`--jdb-${name}`);\n   }\n\n   if (!(name in vars)) {\n\n      /* usage in css: .uk-name:before { content:\"xyz\" } */\n\n      const element = append(docEl, document.createElement('div'));\n\n      addClass(element, `jdb-${name}`);\n\n      vars[name] = getStyle(element, 'content', ':before').replace(/^[\"'](.*)[\"']$/, '$1');\n\n      remove(element);\n\n   }\n\n   return vars[name];\n\n}\n\nconst cssProps = {};\n\nfunction style_propName(name) {\n\n   let ret = cssProps[name];\n   if (!ret) {\n      ret = cssProps[name] = vendorPropName(name) || name;\n   }\n   return ret;\n}\n\nconst cssPrefixes = ['webkit', 'moz', 'ms'];\n\nfunction vendorPropName(name) {\n\n   name = Object(lang[\"hyphenate\"])(name);\n\n   const {style} = document.documentElement;\n\n   if (name in style) {\n      return name;\n   }\n\n   let i = cssPrefixes.length, prefixedName;\n\n   while (i--) {\n      prefixedName = `-${cssPrefixes[i]}-${name}`;\n      if (prefixedName in style) {\n         return prefixedName;\n      }\n   }\n}\n\n// CONCATENATED MODULE: ./src/util/animation.js\n\n\n\n\n\n\n\nfunction animation_transition(element, props, duration = 400, timing = 'linear') {\n\n   return util_promise[\"Promise\"].all(Object(lang[\"toNodes\"])(element).map(element =>\n      new util_promise[\"Promise\"]((resolve, reject) => {\n\n         for (const name in props) {\n            const value = style_css(element, name);\n            if (value === '') {\n               style_css(element, name, value);\n            }\n         }\n\n         const timer = setTimeout(() => trigger(element, 'transitionend'), duration);\n\n         once(element, 'transitionend transitioncanceled', ({type}) => {\n            clearTimeout(timer);\n            removeClass(element, 'jdb-transition');\n            style_css(element, {\n               'transition-property': '',\n               'transition-duration': '',\n               'transition-timing-function': ''\n            });\n            type === 'transitioncanceled' ? reject() : resolve();\n         }, false, ({target}) => element === target);\n\n         addClass(element, 'jdb-transition');\n         style_css(element, Object(lang[\"assign\"])({\n            'transition-property': Object.keys(props).map(style_propName).join(','),\n            'transition-duration': `${duration}ms`,\n            'transition-timing-function': timing\n         }, props));\n\n      })\n   ));\n\n}\n\nconst Transition = {\n\n   start: animation_transition,\n\n   stop(element) {\n      trigger(element, 'transitionend');\n      return util_promise[\"Promise\"].resolve();\n   },\n\n   cancel(element) {\n      trigger(element, 'transitioncanceled');\n   },\n\n   inProgress(element) {\n      return hasClass(element, 'jdb-transition');\n   }\n\n};\n\nconst animationPrefix = 'jdb-animation-';\nconst clsCancelAnimation = 'jdb-cancel-animation';\n\nfunction animation_animate(element, animation, duration = 200, origin, out) {\n\n   return util_promise[\"Promise\"].all(Object(lang[\"toNodes\"])(element).map(element =>\n      new util_promise[\"Promise\"]((resolve, reject) => {\n\n         if (hasClass(element, clsCancelAnimation)) {\n            requestAnimationFrame(() =>\n               util_promise[\"Promise\"].resolve().then(() =>\n                  animation_animate(...arguments).then(resolve, reject)\n               )\n            );\n            return;\n         }\n\n         let cls = `${animation} ${animationPrefix}${out ? 'leave' : 'enter'}`;\n\n         if (Object(lang[\"startsWith\"])(animation, animationPrefix)) {\n\n            if (origin) {\n               cls += ` jdb-transform-origin-${origin}`;\n            }\n\n            if (out) {\n               cls += ` ${animationPrefix}reverse`;\n            }\n\n         }\n\n         reset();\n\n         once(element, 'animationend animationcancel', ({type}) => {\n\n            let hasReset = false;\n\n            if (type === 'animationcancel') {\n               reject();\n               reset();\n            } else {\n               resolve();\n               util_promise[\"Promise\"].resolve().then(() => {\n                  hasReset = true;\n                  reset();\n               });\n            }\n\n            requestAnimationFrame(() => {\n               if (!hasReset) {\n                  addClass(element, clsCancelAnimation);\n\n                  requestAnimationFrame(() => removeClass(element, clsCancelAnimation));\n               }\n            });\n\n         }, false, ({target}) => element === target);\n\n         style_css(element, 'animationDuration', `${duration}ms`);\n         addClass(element, cls);\n\n         function reset() {\n            style_css(element, 'animationDuration', '');\n            removeClasses(element, `${animationPrefix}\\\\S*`);\n         }\n\n      })\n   ));\n\n}\n\nconst animation_inProgress = new RegExp(`${animationPrefix}(enter|leave)`);\nconst Animation = {\n\n   in(element, animation, duration, origin) {\n      return animation_animate(element, animation, duration, origin, false);\n   },\n\n   out(element, animation, duration, origin) {\n      return animation_animate(element, animation, duration, origin, true);\n   },\n\n   inProgress(element) {\n      return animation_inProgress.test(attr_attr(element, 'class'));\n   },\n\n   cancel(element) {\n      trigger(element, 'animationcancel');\n   }\n\n};\n\n// CONCATENATED MODULE: ./src/util/dimensions.js\n\n\n\n\n\nconst dirs = {\n    width: ['x', 'left', 'right'],\n    height: ['y', 'top', 'bottom']\n};\n\nfunction positionAt(element, target, elAttach, targetAttach, elOffset, targetOffset, flip, boundary) {\n\n    elAttach = getPos(elAttach);\n    targetAttach = getPos(targetAttach);\n\n    const flipped = {element: elAttach, target: targetAttach};\n\n    if (!element || !target) {\n        return flipped;\n    }\n\n    const dim = getDimensions(element);\n    const targetDim = getDimensions(target);\n    const position = targetDim;\n\n    moveTo(position, elAttach, dim, -1);\n    moveTo(position, targetAttach, targetDim, 1);\n\n    elOffset = getOffsets(elOffset, dim.width, dim.height);\n    targetOffset = getOffsets(targetOffset, targetDim.width, targetDim.height);\n\n    elOffset['x'] += targetOffset['x'];\n    elOffset['y'] += targetOffset['y'];\n\n    position.left += elOffset['x'];\n    position.top += elOffset['y'];\n\n    if (flip) {\n\n        const boundaries = [getDimensions(getWindow(element))];\n\n        if (boundary) {\n            boundaries.unshift(getDimensions(boundary));\n        }\n\n        Object(lang[\"each\"])(dirs, ([dir, align, alignFlip], prop) => {\n\n            if (!(flip === true || Object(lang[\"includes\"])(flip, dir))) {\n                return;\n            }\n\n            boundaries.some(boundary => {\n\n                const elemOffset = elAttach[dir] === align\n                    ? -dim[prop]\n                    : elAttach[dir] === alignFlip\n                        ? dim[prop]\n                        : 0;\n\n                const targetOffset = targetAttach[dir] === align\n                    ? targetDim[prop]\n                    : targetAttach[dir] === alignFlip\n                        ? -targetDim[prop]\n                        : 0;\n\n                if (position[align] < boundary[align] || position[align] + dim[prop] > boundary[alignFlip]) {\n\n                    const centerOffset = dim[prop] / 2;\n                    const centerTargetOffset = targetAttach[dir] === 'center' ? -targetDim[prop] / 2 : 0;\n\n                    return elAttach[dir] === 'center' && (\n                        apply(centerOffset, centerTargetOffset)\n                        || apply(-centerOffset, -centerTargetOffset)\n                    ) || apply(elemOffset, targetOffset);\n\n                }\n\n                function apply(elemOffset, targetOffset) {\n\n                    const newVal = position[align] + elemOffset + targetOffset - elOffset[dir] * 2;\n\n                    if (newVal >= boundary[align] && newVal + dim[prop] <= boundary[alignFlip]) {\n                        position[align] = newVal;\n\n                        ['element', 'target'].forEach(el => {\n                            flipped[el][dir] = !elemOffset\n                                ? flipped[el][dir]\n                                : flipped[el][dir] === dirs[prop][1]\n                                    ? dirs[prop][2]\n                                    : dirs[prop][1];\n                        });\n\n                        return true;\n                    }\n\n                }\n\n            });\n\n        });\n    }\n\n    dimensions_offset(element, position);\n\n    return flipped;\n}\n\nfunction dimensions_offset(element, coordinates) {\n\n    element = Object(lang[\"toNode\"])(element);\n\n    if (coordinates) {\n\n        const currentOffset = dimensions_offset(element);\n        const pos = style_css(element, 'position');\n\n        ['left', 'top'].forEach(prop => {\n            if (prop in coordinates) {\n                const value = style_css(element, prop);\n                style_css(element, prop, coordinates[prop] - currentOffset[prop]\n                    + Object(lang[\"toFloat\"])(pos === 'absolute' && value === 'auto'\n                        ? dimensions_position(element)[prop]\n                        : value)\n                );\n            }\n        });\n\n        return;\n    }\n\n    return getDimensions(element);\n}\n\nfunction getDimensions(element) {\n\n    element = Object(lang[\"toNode\"])(element);\n\n    const {pageYOffset: top, pageXOffset: left} = getWindow(element);\n\n    if (Object(lang[\"isWindow\"])(element)) {\n\n        const height = element.innerHeight;\n        const width = element.innerWidth;\n\n        return {\n            top,\n            left,\n            height,\n            width,\n            bottom: top + height,\n            right: left + width\n        };\n    }\n\n    let style, hidden;\n\n    if (!isVisible(element) && style_css(element, 'display') === 'none') {\n\n        style = attr_attr(element, 'style');\n        hidden = attr_attr(element, 'hidden');\n\n        attr_attr(element, {\n            style: `${style || ''};display:block !important;`,\n            hidden: null\n        });\n    }\n\n    const rect = element.getBoundingClientRect();\n\n    if (!Object(lang[\"isUndefined\"])(style)) {\n        attr_attr(element, {style, hidden});\n    }\n\n    return {\n        height: rect.height,\n        width: rect.width,\n        top: rect.top + top,\n        left: rect.left + left,\n        bottom: rect.bottom + top,\n        right: rect.right + left\n    };\n}\n\nfunction dimensions_position(element) {\n    element = Object(lang[\"toNode\"])(element);\n\n    const parent = element.offsetParent || getDocEl(element);\n    const parentOffset = dimensions_offset(parent);\n    const {top, left} = ['top', 'left'].reduce((props, prop) => {\n        const propName = Object(lang[\"ucfirst\"])(prop);\n        props[prop] -= parentOffset[prop]\n            + Object(lang[\"toFloat\"])(style_css(element, `margin${propName}`))\n            + Object(lang[\"toFloat\"])(style_css(parent, `border${propName}Width`));\n        return props;\n    }, dimensions_offset(element));\n\n    return {top, left};\n}\n\nconst dimensions_height = dimension('height');\nconst dimensions_width = dimension('width');\n\nfunction dimension(prop) {\n    const propName = Object(lang[\"ucfirst\"])(prop);\n    return (element, value) => {\n\n        element = Object(lang[\"toNode\"])(element);\n\n        if (Object(lang[\"isUndefined\"])(value)) {\n\n            if (Object(lang[\"isWindow\"])(element)) {\n                return element[`inner${propName}`];\n            }\n\n            if (Object(lang[\"isDocument\"])(element)) {\n                const doc = element.documentElement;\n                return Math.max(doc[`offset${propName}`], doc[`scroll${propName}`]);\n            }\n\n            value = style_css(element, prop);\n            value = value === 'auto' ? element[`offset${propName}`] : Object(lang[\"toFloat\"])(value) || 0;\n\n            return value - boxModelAdjust(prop, element);\n\n        } else {\n\n            style_css(element, prop, !value && value !== 0\n                ? ''\n                : +value + boxModelAdjust(prop, element) + 'px'\n            );\n\n        }\n\n    };\n}\n\nfunction boxModelAdjust(prop, element, sizing = 'border-box') {\n    return style_css(element, 'boxSizing') === sizing\n        ? dirs[prop].slice(1).map(lang[\"ucfirst\"]).reduce((value, prop) =>\n            value\n            + Object(lang[\"toFloat\"])(style_css(element, `padding${prop}`))\n            + Object(lang[\"toFloat\"])(style_css(element, `border${prop}Width`))\n            , 0)\n        : 0;\n}\n\nfunction moveTo(position, attach, dim, factor) {\n    Object(lang[\"each\"])(dirs, ([dir, align, alignFlip], prop) => {\n        if (attach[dir] === alignFlip) {\n            position[align] += dim[prop] * factor;\n        } else if (attach[dir] === 'center') {\n            position[align] += dim[prop] * factor / 2;\n        }\n    });\n}\n\nfunction getPos(pos) {\n\n    const x = /left|center|right/;\n    const y = /top|center|bottom/;\n\n    pos = (pos || '').split(' ');\n\n    if (pos.length === 1) {\n        pos = x.test(pos[0])\n            ? pos.concat(['center'])\n            : y.test(pos[0])\n                ? ['center'].concat(pos)\n                : ['center', 'center'];\n    }\n\n    return {\n        x: x.test(pos[0]) ? pos[0] : 'center',\n        y: y.test(pos[1]) ? pos[1] : 'center'\n    };\n}\n\nfunction getOffsets(offsets, width, height) {\n\n    const [x, y] = (offsets || '').split(' ');\n\n    return {\n        x: x ? Object(lang[\"toFloat\"])(x) * (Object(lang[\"endsWith\"])(x, '%') ? width / 100 : 1) : 0,\n        y: y ? Object(lang[\"toFloat\"])(y) * (Object(lang[\"endsWith\"])(y, '%') ? height / 100 : 1) : 0\n    };\n}\n\nfunction flipPosition(pos) {\n    switch (pos) {\n        case 'left':\n            return 'right';\n        case 'right':\n            return 'left';\n        case 'top':\n            return 'bottom';\n        case 'bottom':\n            return 'top';\n        default:\n            return pos;\n    }\n}\n\nfunction isInView(element, topOffset = 0, leftOffset = 0) {\n\n    if (!isVisible(element)) {\n        return false;\n    }\n\n    element = Object(lang[\"toNode\"])(element);\n\n    const win = getWindow(element);\n    const client = element.getBoundingClientRect();\n    const bounding = {\n        top: -topOffset,\n        left: -leftOffset,\n        bottom: topOffset + dimensions_height(win),\n        right: leftOffset + dimensions_width(win)\n    };\n\n    return Object(lang[\"intersectRect\"])(client, bounding) || Object(lang[\"pointInRect\"])({x: client.left, y: client.top}, bounding);\n\n}\n\nfunction scrolledOver(element, heightOffset = 0) {\n\n    if (!isVisible(element)) {\n        return 0;\n    }\n\n    element = Object(lang[\"toNode\"])(element);\n\n    const win = getWindow(element);\n    const doc = getDocument(element);\n    const elHeight = element.offsetHeight + heightOffset;\n    const [top] = offsetPosition(element);\n    const vp = dimensions_height(win);\n    const vh = vp + Math.min(0, top - vp);\n    const diff = Math.max(0, vp - (dimensions_height(doc) + heightOffset - (top + elHeight)));\n\n    return Object(lang[\"clamp\"])(((vh + win.pageYOffset - top) / ((vh + (elHeight - (diff < vp ? diff : 0))) / 100)) / 100);\n}\n\nfunction scrollTop(element, top) {\n    element = Object(lang[\"toNode\"])(element);\n\n    if (Object(lang[\"isWindow\"])(element) || Object(lang[\"isDocument\"])(element)) {\n        const {scrollTo, pageXOffset} = getWindow(element);\n        scrollTo(pageXOffset, top);\n    } else {\n        element.scrollTop = top;\n    }\n}\n\nfunction offsetPosition(element) {\n    const offset = [0, 0];\n\n    do {\n\n        offset[0] += element.offsetTop;\n        offset[1] += element.offsetLeft;\n\n        if (style_css(element, 'position') === 'fixed') {\n            const win = getWindow(element);\n            offset[0] += win.pageYOffset;\n            offset[1] += win.pageXOffset;\n            return offset;\n        }\n\n    } while ((element = element.offsetParent));\n\n    return offset;\n}\n\nfunction toPx(value, property = 'width', element = window) {\n    return Object(lang[\"isNumeric\"])(value)\n        ? +value\n        : Object(lang[\"endsWith\"])(value, 'vh')\n            ? dimensions_percent(dimensions_height(getWindow(element)), value)\n            : Object(lang[\"endsWith\"])(value, 'vw')\n                ? dimensions_percent(dimensions_width(getWindow(element)), value)\n                : Object(lang[\"endsWith\"])(value, '%')\n                    ? dimensions_percent(getDimensions(element)[property], value)\n                    : Object(lang[\"toFloat\"])(value);\n}\n\nfunction dimensions_percent(base, value) {\n    return base * Object(lang[\"toFloat\"])(value) / 100;\n}\n\nfunction getWindow(element) {\n    return Object(lang[\"isWindow\"])(element) ? element : getDocument(element).defaultView;\n}\n\nfunction getDocument(element) {\n    return Object(lang[\"toNode\"])(element).ownerDocument;\n}\n\nfunction getDocEl(element) {\n    return getDocument(element).documentElement;\n}\n\n// CONCATENATED MODULE: ./src/util/fastdom.js\n/*\n    Based on:\n    Copyright (c) 2016 Wilson Page wilsonpage@me.com\n    https://github.com/wilsonpage/fastdom\n*/\n\nconst fastdom = {\n\n    reads: [],\n    writes: [],\n\n    read(task) {\n        this.reads.push(task);\n        scheduleFlush();\n        return task;\n    },\n\n    write(task) {\n        this.writes.push(task);\n        scheduleFlush();\n        return task;\n    },\n\n    clear(task) {\n        return fastdom_remove(this.reads, task) || fastdom_remove(this.writes, task);\n    },\n\n    flush() {\n\n        runTasks(this.reads);\n        runTasks(this.writes.splice(0, this.writes.length));\n\n        this.scheduled = false;\n\n        if (this.reads.length || this.writes.length) {\n            scheduleFlush();\n        }\n\n    }\n\n};\n\nfunction scheduleFlush() {\n    if (!fastdom.scheduled) {\n        fastdom.scheduled = true;\n        requestAnimationFrame(fastdom.flush.bind(fastdom));\n    }\n}\n\nfunction runTasks(tasks) {\n    let task;\n    while ((task = tasks.shift())) {\n        task();\n    }\n}\n\nfunction fastdom_remove(array, item) {\n    const index = array.indexOf(item);\n    return !!~index && !!array.splice(index, 1);\n}\n\n// CONCATENATED MODULE: ./src/util/options.js\n\n\nconst strats = {};\n\nstrats.events =\nstrats.created =\nstrats.beforeConnect =\nstrats.connected =\nstrats.beforeDisconnect =\nstrats.disconnected =\nstrats.destroy = concatStrat;\n\n// args strategy\nstrats.args = function (parentVal, childVal) {\n    return concatStrat(childVal || parentVal);\n};\n\n// update strategy\nstrats.update = function (parentVal, childVal) {\n    return Object(lang[\"sortBy\"])(concatStrat(parentVal, Object(lang[\"isFunction\"])(childVal) ? {read: childVal} : childVal), 'order');\n};\n\n// property strategy\nstrats.props = function (parentVal, childVal) {\n\n    if (Object(lang[\"isArray\"])(childVal)) {\n        childVal = childVal.reduce((value, key) => {\n            value[key] = String;\n            return value;\n        }, {});\n    }\n\n    return strats.methods(parentVal, childVal);\n};\n\n// extend strategy\nstrats.computed =\nstrats.methods = function (parentVal, childVal) {\n    return childVal\n        ? parentVal\n            ? Object(lang[\"assign\"])({}, parentVal, childVal)\n            : childVal\n        : parentVal;\n};\n\n// data strategy\nstrats.data = function (parentVal, childVal, vm) {\n\n    if (!vm) {\n\n        if (!childVal) {\n            return parentVal;\n        }\n\n        if (!parentVal) {\n            return childVal;\n        }\n\n        return function (vm) {\n            return mergeFnData(parentVal, childVal, vm);\n        };\n\n    }\n\n    return mergeFnData(parentVal, childVal, vm);\n};\n\nfunction mergeFnData(parentVal, childVal, vm) {\n    return strats.computed(\n        Object(lang[\"isFunction\"])(parentVal)\n            ? parentVal.call(vm, vm)\n            : parentVal,\n        Object(lang[\"isFunction\"])(childVal)\n            ? childVal.call(vm, vm)\n            : childVal\n    );\n}\n\n// concat strategy\nfunction concatStrat(parentVal, childVal) {\n\n    parentVal = parentVal && !Object(lang[\"isArray\"])(parentVal) ? [parentVal] : parentVal;\n\n    return childVal\n        ? parentVal\n            ? parentVal.concat(childVal)\n            : Object(lang[\"isArray\"])(childVal)\n                ? childVal\n                : [childVal]\n        : parentVal;\n}\n\n// default strategy\nfunction defaultStrat(parentVal, childVal) {\n    return Object(lang[\"isUndefined\"])(childVal) ? parentVal : childVal;\n}\n\nfunction mergeOptions(parent, child, vm) {\n\n    const options = {};\n\n    if (Object(lang[\"isFunction\"])(child)) {\n        child = child.options;\n    }\n\n    if (child.extends) {\n        parent = mergeOptions(parent, child.extends, vm);\n    }\n\n    if (child.mixins) {\n        for (let i = 0, l = child.mixins.length; i < l; i++) {\n            parent = mergeOptions(parent, child.mixins[i], vm);\n        }\n    }\n\n    for (const key in parent) {\n        mergeKey(key);\n    }\n\n    for (const key in child) {\n        if (!Object(lang[\"hasOwn\"])(parent, key)) {\n            mergeKey(key);\n        }\n    }\n\n    function mergeKey(key) {\n        options[key] = (strats[key] || defaultStrat)(parent[key], child[key], vm);\n    }\n\n    return options;\n}\n\nfunction parseOptions(options, args = []) {\n\n    try {\n\n        return !options\n            ? {}\n            : Object(lang[\"startsWith\"])(options, '{')\n                ? JSON.parse(options)\n                : args.length && !Object(lang[\"includes\"])(options, ':')\n                    ? ({[args[0]]: options})\n                    : options.split(';').reduce((options, option) => {\n                        const [key, value] = option.split(/:(.*)/);\n                        if (key && !Object(lang[\"isUndefined\"])(value)) {\n                            options[key.trim()] = value.trim();\n                        }\n                        return options;\n                    }, {});\n\n    } catch (e) {\n        return {};\n    }\n\n}\n\n// CONCATENATED MODULE: ./src/util/image.js\n\n\nfunction getImage(src, srcset, sizes) {\n\n    return new util_promise[\"Promise\"]((resolve, reject) => {\n        const img = new Image();\n\n        img.onerror = reject;\n        img.onload = () => resolve(img);\n\n        sizes && (img.sizes = sizes);\n        srcset && (img.srcset = srcset);\n        img.src = src;\n    });\n\n}\n\n// CONCATENATED MODULE: ./src/util/uniqueid.js\nconst jdbPackIdCounter = {}\n\nfunction uniqueid(prefix = 'jdb-') {\n    if (!jdbPackIdCounter[prefix]) {\n        jdbPackIdCounter[prefix] = 0\n    }\n\n    const id = ++jdbPackIdCounter[prefix];\n    return `${prefix}${id}`\n}\n// CONCATENATED MODULE: ./src/util/index.js\n//export * from './ajax';\n\n\n\n\n\n\n\n\n\n\n//export * from './mouse';\n\n//export * from './player';\n\n//export * from './intersection';\n\n\n\n\n\n// CONCATENATED MODULE: ./src/api/component.js\n\n\n/* harmony default export */ var api_component = (function (UIkit) {\n\n   const DATA = UIkit.data;\n\n   const components = {};\n\n   UIkit.component = function (name, options) {\n\n      if (!options) {\n\n         if (Object(lang[\"isPlainObject\"])(components[name])) {\n            components[name] = UIkit.extend(components[name]);\n         }\n\n         return components[name];\n\n      }\n\n      UIkit[name] = function (element, data) {\n\n         const component = UIkit.component(name);\n\n         if (Object(lang[\"isPlainObject\"])(element)) {\n            return new component({data: element});\n         }\n\n         if (component.options.functional) {\n            return new component({data: [...arguments]});\n         }\n\n         return element && element.nodeType ? init(element) : $$(element).map(init)[0];\n\n         function init(element) {\n\n            const instance = UIkit.getComponent(element, name);\n\n            if (instance) {\n               if (!data) {\n                  return instance;\n               } else {\n                  instance.$destroy();\n               }\n            }\n\n            return new component({el: element, data});\n\n         }\n\n      };\n\n      const opt = Object(lang[\"isPlainObject\"])(options) ? Object(lang[\"assign\"])({}, options) : options.options;\n\n      opt.name = name;\n\n      if (opt.install) {\n         opt.install(UIkit, opt, name);\n      }\n\n      if (UIkit._initialized && !opt.functional) {\n         const id = Object(lang[\"hyphenate\"])(name);\n         fastdom.read(() => UIkit[name](`[jdb-${id}],[data-jdb-${id}]`));\n      }\n\n      return components[name] = Object(lang[\"isPlainObject\"])(options) ? opt : options;\n   };\n\n   UIkit.getComponents = element => element && element[DATA] || {};\n   UIkit.getComponent = (element, name) => UIkit.getComponents(element)[name];\n\n   UIkit.connect = node => {\n\n      if (node[DATA]) {\n         for (const name in node[DATA]) {\n            node[DATA][name]._callConnected();\n         }\n      }\n\n      for (let i = 0; i < node.attributes.length; i++) {\n\n         const name = getComponentName(node.attributes[i].name);\n\n         if (name && name in components) {\n            UIkit[name](node);\n         }\n\n      }\n\n   };\n\n   UIkit.disconnect = node => {\n      for (const name in node[DATA]) {\n         node[DATA][name]._callDisconnected();\n      }\n   };\n\n});\n\nfunction getComponentName(attribute) {\n   return Object(lang[\"startsWith\"])(attribute, 'jdb-') || Object(lang[\"startsWith\"])(attribute, 'data-jdb-')\n           ? Object(lang[\"camelize\"])(attribute.replace('data-jdb-', '').replace('jdb-', ''))\n           : false;\n}\n\n// CONCATENATED MODULE: ./src/api/boot.js\n\n\n\n/* harmony default export */ var boot = (function (UIkit) {\n\n   const {connect, disconnect} = UIkit;\n\n   if (!('MutationObserver' in window)) {\n      return;\n   }\n\n   if (document.body) {\n\n      init();\n\n   } else {\n\n      (new MutationObserver(function () {\n\n         if (document.body) {\n            this.disconnect();\n            init();\n         }\n\n      })).observe(document, {childList: true, subtree: true});\n\n   }\n\n   function init() {\n\n      apply(document.body, connect);\n\n      fastdom.flush();\n\n      (new MutationObserver(mutations => mutations.forEach(applyMutation))).observe(document, {\n         childList: true,\n         subtree: true,\n         characterData: true,\n         attributes: true\n      });\n\n      UIkit._initialized = true;\n   }\n\n   function applyMutation(mutation) {\n\n      const {target, type} = mutation;\n\n      const update = type !== 'attributes'\n              ? applyChildList(mutation)\n              : applyAttribute(mutation);\n\n      update && UIkit.update(target);\n\n   }\n\n   function applyAttribute( {target, attributeName}) {\n\n      if (attributeName === 'href') {\n         return true;\n      }\n\n      const name = getComponentName(attributeName);\n      \n      if (!name || !(name in UIkit)) {\n         return;\n      }\n\n      if (hasAttr(target, attributeName)) {\n         UIkit[name](target);\n         return true;\n      }\n\n      const component = UIkit.getComponent(target, name);\n\n      if (component) {\n         component.$destroy();\n         return true;\n   }\n\n   }\n\n   function applyChildList( {addedNodes, removedNodes}) {\n\n      for (let i = 0; i < addedNodes.length; i++) {\n         apply(addedNodes[i], connect);\n      }\n\n      for (let i = 0; i < removedNodes.length; i++) {\n         apply(removedNodes[i], disconnect);\n      }\n\n      return true;\n   }\n\n   function apply(node, fn) {\n\n      if (node.nodeType !== 1 || hasAttr(node, 'jdb-no-boot')) {\n         return;\n      }\n\n      fn(node);\n      node = node.firstElementChild;\n      while (node) {\n         const next = node.nextElementSibling;\n         apply(node, fn);\n         node = next;\n      }\n   }\n\n});\n\n// CONCATENATED MODULE: ./src/api/global.js\n\n\n/* harmony default export */ var global = (function (UIkit) {\n\n    const DATA = UIkit.data;\n\n    UIkit.use = function (plugin) {\n\n        if (plugin.installed) {\n            return;\n        }\n\n        plugin.call(null, this);\n        plugin.installed = true;\n\n        return this;\n    };\n\n    UIkit.mixin = function (mixin, component) {\n        component = (Object(lang[\"isString\"])(component) ? UIkit.component(component) : component) || this;\n        component.options = mergeOptions(component.options, mixin);\n    };\n\n    UIkit.extend = function (options) {\n\n        options = options || {};\n\n        const Super = this;\n        const Sub = function UIkitComponent(options) {\n            this._init(options);\n        };\n\n        Sub.prototype = Object.create(Super.prototype);\n        Sub.prototype.constructor = Sub;\n        Sub.options = mergeOptions(Super.options, options);\n\n        Sub.super = Super;\n        Sub.extend = Super.extend;\n\n        return Sub;\n    };\n\n    UIkit.update = function (element, e) {\n\n        element = element ? Object(lang[\"toNode\"])(element) : document.body;\n\n        path(element, element => update(element[DATA], e));\n        dom_apply(element, element => update(element[DATA], e));\n\n    };\n\n    let container;\n    Object.defineProperty(UIkit, 'container', {\n\n        get() {\n            return container || document.body;\n        },\n\n        set(element) {\n            container = dom_$(element);\n        }\n\n    });\n\n    function update(data, e) {\n\n        if (!data) {\n            return;\n        }\n\n        for (const name in data) {\n            if (data[name]._connected) {\n                data[name]._callUpdate(e);\n            }\n        }\n\n    }\n\n    function path(node, fn) {\n        if (node && node !== document.body && node.parentNode) {\n            path(node.parentNode, fn);\n            fn(node.parentNode);\n        }\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/api/hooks.js\n\n\n/* harmony default export */ var hooks = (function (UIkit) {\n\n    UIkit.prototype._callHook = function (hook) {\n\n        const handlers = this.$options[hook];\n\n        if (handlers) {\n            handlers.forEach(handler => handler.call(this));\n        }\n    };\n\n    UIkit.prototype._callConnected = function () {\n\n        if (this._connected) {\n            return;\n        }\n\n        this._data = {};\n        this._computeds = {};\n        this._initProps();\n\n        this._callHook('beforeConnect');\n        this._connected = true;\n\n        this._initEvents();\n        this._initObserver();\n\n        this._callHook('connected');\n        this._callUpdate();\n    };\n\n    UIkit.prototype._callDisconnected = function () {\n\n        if (!this._connected) {\n            return;\n        }\n\n        this._callHook('beforeDisconnect');\n\n        if (this._observer) {\n            this._observer.disconnect();\n            this._observer = null;\n        }\n\n        this._unbindEvents();\n        this._callHook('disconnected');\n\n        this._connected = false;\n\n    };\n\n    UIkit.prototype._callUpdate = function (e = 'update') {\n\n        const type = e.type || e;\n\n        if (Object(lang[\"includes\"])(['update', 'resize'], type)) {\n            this._callWatches();\n        }\n\n        const updates = this.$options.update;\n        const {reads, writes} = this._frames;\n\n        if (!updates) {\n            return;\n        }\n\n        updates.forEach(({read, write, events}, i) => {\n\n            if (type !== 'update' && !Object(lang[\"includes\"])(events, type)) {\n                return;\n            }\n\n            if (read && !Object(lang[\"includes\"])(fastdom.reads, reads[i])) {\n                reads[i] = fastdom.read(() => {\n\n                    const result = this._connected && read.call(this, this._data, type);\n\n                    if (result === false && write) {\n                        fastdom.clear(writes[i]);\n                    } else if (Object(lang[\"isPlainObject\"])(result)) {\n                        Object(lang[\"assign\"])(this._data, result);\n                    }\n                });\n            }\n\n            if (write && !Object(lang[\"includes\"])(fastdom.writes, writes[i])) {\n                writes[i] = fastdom.write(() => this._connected && write.call(this, this._data, type));\n            }\n\n        });\n\n    };\n\n});\n\n// CONCATENATED MODULE: ./src/api/state.js\n\n\n/* harmony default export */ var api_state = (function (UIkit) {\n\n    let uid = 0;\n\n    UIkit.prototype._init = function (options) {\n\n        options = options || {};\n        options.data = normalizeData(options, this.constructor.options);\n\n        this.$options = mergeOptions(this.constructor.options, options, this);\n        this.$el = null;\n        this.$props = {};\n\n        this._frames = {reads: {}, writes: {}};\n        this._events = [];\n\n        this._uid = uid++;\n        this._initData();\n        this._initMethods();\n        this._initComputeds();\n        this._callHook('created');\n\n        if (options.el) {\n            this.$mount(options.el);\n        }\n    };\n\n    UIkit.prototype._initData = function () {\n\n        const {data = {}} = this.$options;\n\n        for (const key in data) {\n            this.$props[key] = this[key] = data[key];\n        }\n    };\n\n    UIkit.prototype._initMethods = function () {\n\n        const {methods} = this.$options;\n\n        if (methods) {\n            for (const key in methods) {\n                this[key] = Object(lang[\"bind\"])(methods[key], this);\n            }\n        }\n    };\n\n    UIkit.prototype._initComputeds = function () {\n\n        const {computed} = this.$options;\n\n        this._computeds = {};\n\n        if (computed) {\n            for (const key in computed) {\n                registerComputed(this, key, computed[key]);\n            }\n        }\n    };\n\n    UIkit.prototype._callWatches = function () {\n\n        const {$options: {computed}, _computeds} = this;\n\n        for (const key in _computeds) {\n\n            const value = _computeds[key];\n            delete _computeds[key];\n\n            if (computed[key].watch && !Object(lang[\"isEqual\"])(value, this[key])) {\n                computed[key].watch.call(this, this[key], value);\n            }\n\n        }\n\n    };\n\n    UIkit.prototype._initProps = function (props) {\n\n        let key;\n\n        props = props || getProps(this.$options, this.$name);\n\n        for (key in props) {\n            if (!Object(lang[\"isUndefined\"])(props[key])) {\n                this.$props[key] = props[key];\n            }\n        }\n\n        const exclude = [this.$options.computed, this.$options.methods];\n        for (key in this.$props) {\n            if (key in props && notIn(exclude, key)) {\n                this[key] = this.$props[key];\n            }\n        }\n    };\n\n    UIkit.prototype._initEvents = function () {\n\n        const {events} = this.$options;\n\n        if (events) {\n\n            events.forEach(event => {\n\n                if (!Object(lang[\"hasOwn\"])(event, 'handler')) {\n                    for (const key in event) {\n                        registerEvent(this, event[key], key);\n                    }\n                } else {\n                    registerEvent(this, event);\n                }\n\n            });\n        }\n    };\n\n    UIkit.prototype._unbindEvents = function () {\n        this._events.forEach(unbind => unbind());\n        this._events = [];\n    };\n\n    UIkit.prototype._initObserver = function () {\n\n        let {attrs, props, el} = this.$options;\n        if (this._observer || !props || attrs === false) {\n            return;\n        }\n\n        attrs = Object(lang[\"isArray\"])(attrs) ? attrs : Object.keys(props);\n\n        this._observer = new MutationObserver(() => {\n\n            const data = getProps(this.$options, this.$name);\n            if (attrs.some(key => !Object(lang[\"isUndefined\"])(data[key]) && data[key] !== this.$props[key])) {\n                this.$reset();\n            }\n\n        });\n\n        const filter = attrs.map(key => Object(lang[\"hyphenate\"])(key)).concat(this.$name);\n\n        this._observer.observe(el, {\n            attributes: true,\n            attributeFilter: filter.concat(filter.map(key => `data-${key}`))\n        });\n    };\n\n    function getProps(opts, name) {\n\n        const data = {};\n        const {args = [], props = {}, el} = opts;\n\n        if (!props) {\n            return data;\n        }\n\n        for (const key in props) {\n            const prop = Object(lang[\"hyphenate\"])(key);\n            let value = attr_data(el, prop);\n\n            if (!Object(lang[\"isUndefined\"])(value)) {\n\n                value = props[key] === Boolean && value === ''\n                    ? true\n                    : coerce(props[key], value);\n\n                if (prop === 'target' && (!value || Object(lang[\"startsWith\"])(value, '_'))) {\n                    continue;\n                }\n\n                data[key] = value;\n            }\n        }\n\n        const options = parseOptions(attr_data(el, name), args);\n\n        for (const key in options) {\n            const prop = Object(lang[\"camelize\"])(key);\n            if (props[prop] !== undefined) {\n                data[prop] = coerce(props[prop], options[key]);\n            }\n        }\n\n        return data;\n    }\n\n    function registerComputed(component, key, cb) {\n        Object.defineProperty(component, key, {\n\n            enumerable: true,\n\n            get() {\n\n                const {_computeds, $props, $el} = component;\n\n                if (!Object(lang[\"hasOwn\"])(_computeds, key)) {\n                    _computeds[key] = (cb.get || cb).call(component, $props, $el);\n                }\n\n                return _computeds[key];\n            },\n\n            set(value) {\n\n                const {_computeds} = component;\n\n                _computeds[key] = cb.set ? cb.set.call(component, value) : value;\n\n                if (Object(lang[\"isUndefined\"])(_computeds[key])) {\n                    delete _computeds[key];\n                }\n            }\n\n        });\n    }\n\n    function registerEvent(component, event, key) {\n\n        if (!Object(lang[\"isPlainObject\"])(event)) {\n            event = ({name: key, handler: event});\n        }\n\n        let {name, el, handler, capture, passive, delegate, filter, self} = event;\n        el = Object(lang[\"isFunction\"])(el)\n            ? el.call(component)\n            : el || component.$el;\n\n        if (Object(lang[\"isArray\"])(el)) {\n            el.forEach(el => registerEvent(component, Object(lang[\"assign\"])({}, event, {el}), key));\n            return;\n        }\n\n        if (!el || filter && !filter.call(component)) {\n            return;\n        }\n\n        handler = detail(Object(lang[\"isString\"])(handler) ? component[handler] : Object(lang[\"bind\"])(handler, component));\n\n        if (self) {\n            handler = selfFilter(handler);\n        }\n\n        component._events.push(\n            on(\n                el,\n                name,\n                !delegate\n                    ? null\n                    : Object(lang[\"isString\"])(delegate)\n                        ? delegate\n                        : delegate.call(component),\n                handler,\n                Object(lang[\"isBoolean\"])(passive)\n                    ? {passive, capture}\n                    : capture\n            )\n        );\n\n    }\n\n    function selfFilter(handler) {\n        return function selfHandler(e) {\n            if (e.target === e.currentTarget || e.target === e.current) {\n                return handler.call(null, e);\n            }\n        };\n    }\n\n    function notIn(options, key) {\n        return options.every(arr => !arr || !Object(lang[\"hasOwn\"])(arr, key));\n    }\n\n    function detail(listener) {\n        return e => Object(lang[\"isArray\"])(e.detail) ? listener(...[e].concat(e.detail)) : listener(e);\n    }\n\n    function coerce(type, value) {\n\n        if (type === Boolean) {\n            return Object(lang[\"toBoolean\"])(value);\n        } else if (type === Number) {\n            return Object(lang[\"toNumber\"])(value);\n        } else if (type === 'list') {\n            return Object(lang[\"toList\"])(value);\n        }\n\n        return type ? type(value) : value;\n    }\n\n    function normalizeData({data, el}, {args, props = {}}) {\n        data = Object(lang[\"isArray\"])(data)\n            ? !Object(lang[\"isEmpty\"])(args)\n                ? data.slice(0, args.length).reduce((data, value, index) => {\n                    if (Object(lang[\"isPlainObject\"])(value)) {\n                        Object(lang[\"assign\"])(data, value);\n                    } else {\n                        data[args[index]] = value;\n                    }\n                    return data;\n                }, {})\n                : undefined\n            : data;\n\n        if (data) {\n            for (const key in data) {\n                if (Object(lang[\"isUndefined\"])(data[key])) {\n                    delete data[key];\n                } else {\n                    data[key] = props[key] ? coerce(props[key], data[key], el) : data[key];\n                }\n            }\n        }\n\n        return data;\n    }\n});\n\n// CONCATENATED MODULE: ./src/api/instance.js\n\n\n/* harmony default export */ var instance = (function (UIkit) {\n\n    const DATA = UIkit.data;\n\n    UIkit.prototype.$mount = function (el) {\n\n        const {name} = this.$options;\n\n        if (!el[DATA]) {\n            el[DATA] = {};\n        }\n\n        if (el[DATA][name]) {\n            return;\n        }\n\n        el[DATA][name] = this;\n\n        this.$el = this.$options.el = this.$options.el || el;\n\n        if (within(el, document)) {\n            this._callConnected();\n        }\n    };\n\n    UIkit.prototype.$emit = function (e) {\n        this._callUpdate(e);\n    };\n\n    UIkit.prototype.$reset = function () {\n        this._callDisconnected();\n        this._callConnected();\n    };\n\n    UIkit.prototype.$destroy = function (removeEl = false) {\n\n        const {el, name} = this.$options;\n\n        if (el) {\n            this._callDisconnected();\n        }\n\n        this._callHook('destroy');\n\n        if (!el || !el[DATA]) {\n            return;\n        }\n\n        delete el[DATA][name];\n\n        if (!Object(lang[\"isEmpty\"])(el[DATA])) {\n            delete el[DATA];\n        }\n\n        if (removeEl) {\n            remove(this.$el);\n        }\n    };\n\n    UIkit.prototype.$create = function (component, element, data) {\n        return UIkit[component](element, data);\n    };\n\n    UIkit.prototype.$update = UIkit.update;\n    UIkit.prototype.$getComponent = UIkit.getComponent;\n\n    const names = {};\n    Object.defineProperties(UIkit.prototype, {\n\n        $container: Object.getOwnPropertyDescriptor(UIkit, 'container'),\n\n        $name: {\n\n            get() {\n                const {name} = this.$options;\n\n                if (!names[name]) {\n                    names[name] = UIkit.prefix + Object(lang[\"hyphenate\"])(name);\n                }\n\n                return names[name];\n            }\n\n        }\n\n    });\n\n});\n\n// CONCATENATED MODULE: ./src/api/index.js\n\n\n\n\n\n\n\nconst api_UIkit = function (options) {\n    this._init(options);\n};\n\napi_UIkit.util = util_namespaceObject;\napi_UIkit.data = '__jdbpack__';\napi_UIkit.prefix = 'jdb-';\napi_UIkit.options = {};\n\nglobal(api_UIkit);\nhooks(api_UIkit);\napi_state(api_UIkit);\napi_component(api_UIkit);\ninstance(api_UIkit);\n\n/* harmony default export */ var api = (api_UIkit);\n\n// CONCATENATED MODULE: ./src/core/core.js\n\n\n/* harmony default export */ var core = (function (UIkit) {\n\n   ready(() => {\n\n      UIkit.update();\n      on(window, 'load resize', () => UIkit.update(null, 'resize'));\n      on(document, 'loadedmetadata load', ({target}) => UIkit.update(target, 'resize'), true);\n\n      // throttle `scroll` event (Safari triggers multiple `scroll` events per frame)\n      let pending;\n      on(window, 'scroll', e => {\n\n         if (pending) {\n            return;\n         }\n         pending = true;\n         fastdom.write(() => pending = false);\n\n         const {target} = e;\n         UIkit.update(target.nodeType !== 1 ? document.body : target, e.type);\n\n      }, {passive: true, capture: true});\n\n      let started = 0;\n      on(document, 'animationstart', ({target}) => {\n         if ((style_css(target, 'animationName') || '').match(/^uk-.*(left|right)/)) {\n\n            started++;\n            style_css(document.body, 'overflowX', 'hidden');\n            setTimeout(() => {\n               if (!--started) {\n                  style_css(document.body, 'overflowX', '');\n               }\n            }, Object(lang[\"toMs\"])(style_css(target, 'animationDuration')) + 100);\n      }\n      }, true);\n\n   });\n\n   let off;\n\n   on(document, pointerDown, e => {\n\n      off && off();\n\n      if (!isTouch(e)) {\n         return;\n      }\n\n      const pos = getEventPos(e);\n      const target = 'tagName' in e.target ? e.target : e.target.parentNode;\n      off = once(document, pointerUp, e => {\n\n         const {x, y} = getEventPos(e);\n\n         // swipe\n         if (target && x && Math.abs(pos.x - x) > 100 || y && Math.abs(pos.y - y) > 100) {\n\n            setTimeout(() => {\n               trigger(target, 'swipe');\n               trigger(target, `swipe${swipeDirection(pos.x, pos.y, x, y)}`);\n            });\n\n         }\n\n      });\n   }, {passive: true});\n\n});\n\nfunction swipeDirection(x1, y1, x2, y2) {\n   return Math.abs(x1 - x2) >= Math.abs(y1 - y2)\n           ? x1 - x2 > 0\n           ? 'Left'\n           : 'Right'\n           : y1 - y2 > 0\n           ? 'Up'\n           : 'Down';\n}\n\n// CONCATENATED MODULE: ./src/mixin/class.js\n\n\n/* harmony default export */ var mixin_class = ({\n\n    connected() {\n        !hasClass(this.$el, this.$name) && addClass(this.$el, this.$name);\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/core/jdbp/loader.js\n\n\n/* harmony default export */ var loader = ({\n\n    mixins: [mixin_class],\n\n    props: {\n        size: String,\n        type: String\n    },\n\n    data: {\n        size: '',\n        type: 'border'\n    },\n\n    methods: {\n        init() {\n            $JDB(this.$el).html('<div class=\"jdb-loader-' + this.type + (this.size == 'sm' ? ' jdb-loader-' + this.type + '-sm' : '') + '\"></div>');\n        },\n        hide() {\n            this.$destroy(true);\n        }\n    },\n\n    connected() {\n        this.init();\n    }\n\n});\n// CONCATENATED MODULE: ./src/core/jdbp/section.js\n\n\n/* harmony default export */ var section = ({\n\n   mixins: [mixin_class],\n\n   props: {\n      ukey: String,\n      stretch: Boolean,\n   },\n\n   data: {\n      ukey: '',\n      stretch: false\n   },\n\n   methods: {\n      init() {\n         if (this.stretch) {\n            style_css(this.$el, 'position', 'relative');\n            style_css(this.$el, 'width', document.body.clientWidth + 'px');\n\n            let offsetTop, offsetLeft;\n            setTimeout(() => {\n               [offsetTop, offsetLeft] = offsetPosition(this.$el);\n\n               let _left = parseInt(style_css(this.$el, 'left'));\n\n               if (offsetLeft !== 0) {\n                  style_css(this.$el, 'left', (_left + (0 - offsetLeft)) + 'px');\n               }\n            });\n         } else {\n            style_css(this.$el, 'position', '');\n            style_css(this.$el, 'width', '');\n            style_css(this.$el, 'left', '');\n         }\n      }\n   },\n\n   connected() {\n      this.init();\n   },\n\n   events: [\n\n      {\n         name: 'load resize',\n         el: window,\n         handler() {\n            this.init();\n         }\n      }\n   ],\n\n});\n// CONCATENATED MODULE: ./src/core/jdbp/row.js\n/* harmony default export */ var row = ({\n    props: {\n        cols: String\n    },\n    data: {\n        cols: ''\n    },\n    methods: {\n        init() {\n            window.dispatchEvent(new Event('resize'));\n        }\n    },\n\n    connected() {\n        this.init();\n    }\n});\n// CONCATENATED MODULE: ./src/mixin/togglable.js\n\n\n/* harmony default export */ var togglable = ({\n\n    props: {\n        cls: Boolean,\n        animation: 'list',\n        duration: Number,\n        origin: String,\n        transition: String,\n        queued: Boolean\n    },\n\n    data: {\n        cls: false,\n        animation: [false],\n        duration: 200,\n        origin: false,\n        transition: 'linear',\n        queued: false,\n\n        initProps: {\n            overflow: '',\n            height: '',\n            paddingTop: '',\n            paddingBottom: '',\n            marginTop: '',\n            marginBottom: ''\n        },\n\n        hideProps: {\n            overflow: 'hidden',\n            height: 0,\n            paddingTop: 0,\n            paddingBottom: 0,\n            marginTop: 0,\n            marginBottom: 0\n        }\n\n    },\n\n    computed: {\n\n        hasAnimation({animation}) {\n            return !!animation[0];\n        },\n\n        hasTransition({animation}) {\n            return this.hasAnimation && animation[0] === true;\n        }\n\n    },\n\n    methods: {\n\n        toggleElement(targets, show, animate) {\n            return new util_promise[\"Promise\"](resolve => {\n\n                targets = Object(lang[\"toNodes\"])(targets);\n\n                const all = targets => util_promise[\"Promise\"].all(targets.map(el => this._toggleElement(el, show, animate)));\n                const toggled = targets.filter(el => this.isToggled(el));\n                const untoggled = targets.filter(el => !Object(lang[\"includes\"])(toggled, el));\n\n                let p;\n\n                if (!this.queued || !Object(lang[\"isUndefined\"])(animate) || !Object(lang[\"isUndefined\"])(show) || !this.hasAnimation || targets.length < 2) {\n\n                    p = all(untoggled.concat(toggled));\n\n                } else {\n\n                    const {body} = document;\n                    const scroll = body.scrollTop;\n                    const [el] = toggled;\n                    const inProgress = Animation.inProgress(el) && hasClass(el, 'jdb-animation-leave')\n                            || Transition.inProgress(el) && el.style.height === '0px';\n\n                    p = all(toggled);\n\n                    if (!inProgress) {\n                        p = p.then(() => {\n                            const p = all(untoggled);\n                            body.scrollTop = scroll;\n                            return p;\n                        });\n                    }\n\n                }\n\n                p.then(resolve, lang[\"noop\"]);\n\n            });\n        },\n\n        toggleNow(targets, show) {\n            return new util_promise[\"Promise\"](resolve => util_promise[\"Promise\"].all(Object(lang[\"toNodes\"])(targets).map(el => this._toggleElement(el, show, false))).then(resolve, lang[\"noop\"]));\n        },\n\n        isToggled(el) {\n            const nodes = Object(lang[\"toNodes\"])(el || this.$el);\n            return this.cls\n                ? hasClass(nodes, this.cls.split(' ')[0])\n                : !hasAttr(nodes, 'hidden');\n        },\n\n        updateAria(el) {\n            if (this.cls === false) {\n                attr_attr(el, 'aria-hidden', !this.isToggled(el));\n            }\n        },\n\n        _toggleElement(el, show, animate) {\n\n            show = Object(lang[\"isBoolean\"])(show)\n                ? show\n                : Animation.inProgress(el)\n                    ? hasClass(el, 'jdb-animation-leave')\n                    : Transition.inProgress(el)\n                        ? el.style.height === '0px'\n                        : !this.isToggled(el);\n\n            if (!trigger(el, `before${show ? 'show' : 'hide'}`, [this])) {\n                return util_promise[\"Promise\"].reject();\n            }\n\n            const promise = (\n                Object(lang[\"isFunction\"])(animate)\n                    ? animate\n                    : animate === false || !this.hasAnimation\n                        ? this._toggle\n                        : this.hasTransition\n                            ? toggleHeight(this)\n                            : toggleAnimation(this)\n            )(el, show);\n\n            trigger(el, show ? 'show' : 'hide', [this]);\n\n            const final = () => {\n                trigger(el, show ? 'shown' : 'hidden', [this]);\n                this.$update(el);\n            };\n\n            return promise ? promise.then(final) : util_promise[\"Promise\"].resolve(final());\n        },\n\n        _toggle(el, toggled) {\n\n            if (!el) {\n                return;\n            }\n\n            toggled = Boolean(toggled);\n\n            let changed;\n            if (this.cls) {\n                changed = Object(lang[\"includes\"])(this.cls, ' ') || toggled !== hasClass(el, this.cls);\n                changed && toggleClass(el, this.cls, Object(lang[\"includes\"])(this.cls, ' ') ? undefined : toggled);\n            } else {\n                changed = toggled === hasAttr(el, 'hidden');\n                changed && attr_attr(el, 'hidden', !toggled ? '' : null);\n            }\n\n            $$('[autofocus]', el).some(el => isVisible(el) ? el.focus() || true : el.blur());\n\n            this.updateAria(el);\n            changed && this.$update(el);\n        }\n\n    }\n\n});\n\nfunction toggleHeight({isToggled, duration, initProps, hideProps, transition, _toggle}) {\n    return (el, show) => {\n\n        const inProgress = Transition.inProgress(el);\n        const inner = el.hasChildNodes ? Object(lang[\"toFloat\"])(style_css(el.firstElementChild, 'marginTop')) + Object(lang[\"toFloat\"])(style_css(el.lastElementChild, 'marginBottom')) : 0;\n        const currentHeight = isVisible(el) ? dimensions_height(el) + (inProgress ? 0 : inner) : 0;\n\n        Transition.cancel(el);\n\n        if (!isToggled(el)) {\n            _toggle(el, true);\n        }\n\n        dimensions_height(el, '');\n\n        // Update child components first\n        fastdom.flush();\n\n        const endHeight = dimensions_height(el) + (inProgress ? 0 : inner);\n        dimensions_height(el, currentHeight);\n\n        return (show\n                ? Transition.start(el, Object(lang[\"assign\"])({}, initProps, {overflow: 'hidden', height: endHeight}), Math.round(duration * (1 - currentHeight / endHeight)), transition)\n                : Transition.start(el, hideProps, Math.round(duration * (currentHeight / endHeight)), transition).then(() => _toggle(el, false))\n        ).then(() => style_css(el, initProps));\n\n    };\n}\n\nfunction toggleAnimation({animation, duration, origin, _toggle}) {\n    return (el, show) => {\n\n        Animation.cancel(el);\n\n        if (show) {\n            _toggle(el, true);\n            return Animation.in(el, animation[0], duration, origin);\n        }\n\n        return Animation.out(el, animation[1] || animation[0], duration, origin).then(() => _toggle(el, false));\n    };\n}\n\n// CONCATENATED MODULE: ./src/core/jdbp/alert.js\n\n\n\n\n/* harmony default export */ var jdbp_alert = ({\n\n   mixins: [mixin_class, togglable],\n\n   args: 'animation',\n\n   props: {\n      close: String\n   },\n\n   data: {\n      animation: [true],\n      selClose: '.jdb-alert-close',\n      duration: 100,\n      hideProps: Object(lang[\"assign\"])({opacity: 0}, togglable.data.hideProps)\n   },\n\n   events: [\n\n      {\n\n         name: 'click',\n\n         delegate() {\n            return this.selClose;\n         },\n\n         handler(e) {\n            e.preventDefault();\n            this.close();\n         }\n\n      }\n\n   ],\n\n   methods: {\n\n      close() {\n         this.toggleElement(this.$el).then(() => this.$destroy(true));\n      }\n\n   }\n\n});\n\n// CONCATENATED MODULE: ./src/core/jdbp/accordion.js\n\n\n\n\n/* harmony default export */ var accordion = ({\n\n   mixins: [mixin_class, togglable],\n\n   props: {\n      targets: String,\n      active: null,\n      collapsible: Boolean,\n      multiple: Boolean,\n      toggle: String,\n      content: String,\n      transition: String\n   },\n\n   data: {\n      targets: '> *',\n      active: false,\n      animation: [true],\n      collapsible: true,\n      multiple: false,\n      clsOpen: 'jdb-active',\n      toggle: '> .jdb-accordion-title',\n      content: '> .jdb-accordion-content',\n      transition: 'ease'\n   },\n\n   computed: {\n\n      items( {targets}, $el) {\n         return $$(targets, $el);\n      }\n\n   },\n\n   events: [\n\n      {\n\n         name: 'click',\n\n         delegate() {\n            return `${this.targets} ${this.$props.toggle}`;\n         },\n\n         handler(e) {\n            e.preventDefault();\n            this.toggle(dom_index($$(`${this.targets} ${this.$props.toggle}`, this.$el), e.current));\n         }\n\n      }\n\n   ],\n\n   connected() {\n\n      if (this.active === false) {\n         return;\n      }\n\n      const active = this.items[Number(this.active)];\n      if (active && !hasClass(active, this.clsOpen)) {\n         this.toggle(active, false);\n      }\n   },\n\n   update() {\n\n      this.items.forEach(el => this._toggle(dom_$(this.content, el), hasClass(el, this.clsOpen)));\n\n      const active = !this.collapsible && !hasClass(this.items, this.clsOpen) && this.items[0];\n      if (active) {\n         this.toggle(active, false);\n      }\n   },\n\n   methods: {\n\n      toggle(item, animate) {\n\n         const index = getIndex(item, this.items);\n         const active = filter_filter(this.items, `.${this.clsOpen}`);\n\n         item = this.items[index];\n\n         item && [item]\n                 .concat(!this.multiple && !Object(lang[\"includes\"])(active, item) && active || [])\n                 .forEach(el => {\n\n                    const isItem = el === item;\n                    const state = isItem && !hasClass(el, this.clsOpen);\n\n                    if (!state && isItem && !this.collapsible && active.length < 2) {\n                       return;\n                    }\n\n                    toggleClass(el, this.clsOpen, state);\n\n                    const content = el._wrapper ? el._wrapper.firstElementChild : dom_$(this.content, el);\n\n                    if (!el._wrapper) {\n                       el._wrapper = wrapAll(content, '<div>');\n                       attr_attr(el._wrapper, 'hidden', state ? '' : null);\n                    }\n\n                    this._toggle(content, true);\n                    this.toggleElement(el._wrapper, state, animate).then(() => {\n\n                       if (hasClass(el, this.clsOpen) !== state) {\n                          return;\n                       }\n\n                       if (!state) {\n                          this._toggle(content, false);\n                       }\n\n                       el._wrapper = null;\n                       unwrap(content);\n\n                    });\n\n                 });\n      }\n\n   }\n\n});\n\n// CONCATENATED MODULE: ./src/core/switcher.js\n\n\n\n/* harmony default export */ var switcher = ({\n\n    mixins: [togglable],\n\n    args: 'connect',\n\n    props: {\n        connect: String,\n        toggle: String,\n        active: Number,\n        swiping: Boolean\n    },\n\n    data: {\n        connect: '~.jdb-switcher',\n        toggle: '> * > :first-child',\n        active: 0,\n        swiping: true,\n        cls: 'jdb-active',\n        clsContainer: 'jdb-switcher',\n        attrItem: 'jdb-switcher-item',\n        queued: true\n    },\n\n    computed: {\n\n        connects({connect}, $el) {\n            return queryAll(connect, $el);\n        },\n\n        toggles({toggle}, $el) {\n            return $$(toggle, $el);\n        }\n\n    },\n\n    events: [\n\n        {\n\n            name: 'click',\n\n            delegate() {\n                return `${this.toggle}:not(.jdb-disabled)`;\n            },\n\n            handler(e) {\n                e.preventDefault();\n                this.show(Object(lang[\"toNodes\"])(this.$el.children).filter(el => within(e.current, el))[0]);\n            }\n\n        },\n\n        {\n            name: 'click',\n\n            el() {\n                return this.connects;\n            },\n\n            delegate() {\n                return `[${this.attrItem}],[data-${this.attrItem}]`;\n            },\n\n            handler(e) {\n                e.preventDefault();\n                this.show(attr_data(e.current, this.attrItem));\n            }\n        },\n\n        {\n            name: 'swipeRight swipeLeft',\n\n            filter() {\n                return this.swiping;\n            },\n\n            el() {\n                return this.connects;\n            },\n\n            handler({type}) {\n                this.show(Object(lang[\"endsWith\"])(type, 'Left') ? 'next' : 'previous');\n            }\n        }\n\n    ],\n\n    update() {\n\n        this.connects.forEach(list => this.updateAria(list.children));\n        const {children} = this.$el;\n        this.show(filter_filter(children, `.${this.cls}`)[0] || children[this.active] || children[0]);\n\n    },\n\n    methods: {\n\n        index() {\n            return !Object(lang[\"isEmpty\"])(this.connects) && dom_index(filter_filter(this.connects[0].children, `.${this.cls}`)[0]);\n        },\n\n        show(item) {\n\n            const {children} = this.$el;\n            const {length} = children;\n            const prev = this.index();\n            const hasPrev = prev >= 0;\n            const dir = item === 'previous' ? -1 : 1;\n\n            let toggle, active, next = getIndex(item, children, prev);\n\n            for (let i = 0; i < length; i++, next = (next + dir + length) % length) {\n                if (!selector_matches(this.toggles[next], '.jdb-disabled *, .jdb-disabled, [disabled]')) {\n                    toggle = this.toggles[next];\n                    active = children[next];\n                    break;\n                }\n            }\n\n            if (!active || prev >= 0 && hasClass(active, this.cls) || prev === next) {\n                return;\n            }\n\n            removeClass(children, this.cls);\n            addClass(active, this.cls);\n            attr_attr(this.toggles, 'aria-expanded', false);\n            attr_attr(toggle, 'aria-expanded', true);\n\n            this.connects.forEach(list => {\n                if (!hasPrev) {\n                    this.toggleNow(list.children[next]);\n                } else {\n                    this.toggleElement([list.children[prev], list.children[next]]);\n                }\n            });\n\n        }\n\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/core/jdbp/tab.js\n\n\n\n\n/* harmony default export */ var tab = ({\n\n   mixins: [mixin_class],\n\n   extends: switcher,\n\n   props: {\n      media: Boolean\n   },\n\n   data: {\n      media: 960,\n      connect: '~.jdb-tab-contents',\n      attrItem: 'jdb-tab-item'\n   },\n\n   connected() {\n\n      const cls = hasClass(this.$el, 'jdb-tab-left')\n              ? 'jdb-tab-left'\n              : hasClass(this.$el, 'jdb-tab-right')\n              ? 'jdb-tab-right'\n              : false;\n\n      if (cls) {\n         this.$create('toggle', this.$el, {cls, mode: 'media', media: this.media});\n      }\n   }\n\n});\n\n// CONCATENATED MODULE: ./src/core/cover.js\n//import Video from './video';\n\n\n\n/* harmony default export */ var cover = ({\n\n    mixins: [mixin_class],\n\n    props: {\n        width: Number,\n        height: Number\n    },\n\n    data: {\n        automute: true\n    },\n\n    update: {\n\n        read() {\n\n            const el = this.$el;\n\n            if (!isVisible(el)) {\n                return false;\n            }\n\n            const {offsetHeight: height, offsetWidth: width} = el.parentNode;\n\n            return {height, width};\n        },\n\n        write({height, width}) {\n\n            const el = this.$el;\n            const elWidth = this.width || el.naturalWidth || el.videoWidth || el.clientWidth;\n            const elHeight = this.height || el.naturalHeight || el.videoHeight || el.clientHeight;\n\n            if (!elWidth || !elHeight) {\n                return;\n            }\n\n            style_css(el, lang[\"Dimensions\"].cover(\n                {\n                    width: elWidth,\n                    height: elHeight\n                },\n                {\n                    width: width + (width % 2 ? 1 : 0),\n                    height: height + (height % 2 ? 1 : 0)\n                }\n            ));\n\n        },\n\n        events: ['resize']\n\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/mixin/slider-autoplay.js\n\n\n/* harmony default export */ var slider_autoplay = ({\n\n    props: {\n        autoplay: Boolean,\n        autoplayInterval: Number,\n        pauseOnHover: Boolean\n    },\n\n    data: {\n        autoplay: false,\n        autoplayInterval: 7000,\n        pauseOnHover: true\n    },\n\n    connected() {\n        this.autoplay && this.startAutoplay();\n    },\n\n    disconnected() {\n        this.stopAutoplay();\n    },\n\n    update() {\n        attr_attr(this.slides, 'tabindex', '-1');\n    },\n\n    events: [\n\n        {\n\n            name: 'visibilitychange',\n\n            el: document,\n\n            filter() {\n                return this.autoplay;\n            },\n\n            handler() {\n                if (document.hidden) {\n                    this.stopAutoplay();\n                } else {\n                    this.startAutoplay();\n                }\n            }\n\n        },\n\n        {\n\n            name: 'mouseenter',\n\n            filter() {\n                return this.autoplay && this.pauseOnHover;\n            },\n\n            handler() {\n                this.isHovering = true;\n            }\n\n        },\n\n        {\n\n            name: 'mouseleave',\n\n            filter() {\n                return this.autoplay && this.pauseOnHover;\n            },\n\n            handler() {\n                this.isHovering = false;\n            }\n\n        }\n\n    ],\n\n    methods: {\n\n        startAutoplay() {\n\n            this.stopAutoplay();\n\n            this.interval = setInterval(\n                () => !within(document.activeElement, this.$el)\n                    && !this.isHovering\n                    && !this.stack.length\n                    && this.show('next'),\n                this.autoplayInterval\n            );\n\n        },\n\n        stopAutoplay() {\n            this.interval && clearInterval(this.interval);\n        }\n\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/mixin/slider-drag.js\n\n\n/* harmony default export */ var slider_drag = ({\n\n    props: {\n        draggable: Boolean\n    },\n\n    data: {\n        draggable: true,\n        threshold: 10\n    },\n\n    created() {\n\n        ['start', 'move', 'end'].forEach(key => {\n\n            const fn = this[key];\n            this[key] = e => {\n\n                const pos = getEventPos(e).x * (isRtl ? -1 : 1);\n\n                this.prevPos = pos !== this.pos ? this.pos : this.prevPos;\n                this.pos = pos;\n\n                fn(e);\n            };\n\n        });\n\n    },\n\n    events: [\n\n        {\n\n            name: pointerDown,\n\n            delegate() {\n                return this.selSlides;\n            },\n\n            handler(e) {\n\n                if (!this.draggable\n                    || !isTouch(e) && hasTextNodesOnly(e.target)\n                    || e.button > 0\n                    || this.length < 2\n                ) {\n                    return;\n                }\n\n                this.start(e);\n            }\n\n        },\n\n        {\n\n            // Workaround for iOS 11 bug: https://bugs.webkit.org/show_bug.cgi?id=184250\n\n            name: 'touchmove',\n            passive: false,\n            handler: 'move',\n            delegate() {\n                return this.selSlides;\n            }\n\n        },\n\n        {\n            name: 'dragstart',\n\n            handler(e) {\n                e.preventDefault();\n            }\n        }\n\n    ],\n\n    methods: {\n\n        start() {\n\n            this.drag = this.pos;\n\n            if (this._transitioner) {\n\n                this.percent = this._transitioner.percent();\n                this.drag += this._transitioner.getDistance() * this.percent * this.dir;\n\n                this._transitioner.cancel();\n                this._transitioner.translate(this.percent);\n\n                this.dragging = true;\n\n                this.stack = [];\n\n            } else {\n                this.prevIndex = this.index;\n            }\n\n            // See above workaround notice\n            const off = pointerMove !== 'touchmove'\n                ? on(document, pointerMove, this.move, {passive: false})\n                : lang[\"noop\"];\n            this.unbindMove = () => {\n                off();\n                this.unbindMove = null;\n            };\n            on(window, 'scroll', this.unbindMove);\n            on(document, pointerUp, this.end, true);\n\n            style_css(this.list, 'userSelect', 'none');\n\n        },\n\n        move(e) {\n\n            // See above workaround notice\n            if (!this.unbindMove) {\n                return;\n            }\n\n            const distance = this.pos - this.drag;\n\n            if (distance === 0 || this.prevPos === this.pos || !this.dragging && Math.abs(distance) < this.threshold) {\n                return;\n            }\n\n            style_css(this.list, 'pointerEvents', 'none');\n\n            e.cancelable && e.preventDefault();\n\n            this.dragging = true;\n            this.dir = (distance < 0 ? 1 : -1);\n\n            const {slides} = this;\n            let {prevIndex} = this;\n            let dis = Math.abs(distance);\n            let nextIndex = this.getIndex(prevIndex + this.dir, prevIndex);\n            let width = this._getDistance(prevIndex, nextIndex) || slides[prevIndex].offsetWidth;\n\n            while (nextIndex !== prevIndex && dis > width) {\n\n                this.drag -= width * this.dir;\n\n                prevIndex = nextIndex;\n                dis -= width;\n                nextIndex = this.getIndex(prevIndex + this.dir, prevIndex);\n                width = this._getDistance(prevIndex, nextIndex) || slides[prevIndex].offsetWidth;\n\n            }\n\n            this.percent = dis / width;\n\n            const prev = slides[prevIndex];\n            const next = slides[nextIndex];\n            const changed = this.index !== nextIndex;\n            const edge = prevIndex === nextIndex;\n\n            let itemShown;\n\n            [this.index, this.prevIndex].filter(i => !Object(lang[\"includes\"])([nextIndex, prevIndex], i)).forEach(i => {\n                trigger(slides[i], 'itemhidden', [this]);\n\n                if (edge) {\n                    itemShown = true;\n                    this.prevIndex = prevIndex;\n                }\n\n            });\n\n            if (this.index === prevIndex && this.prevIndex !== prevIndex || itemShown) {\n                trigger(slides[this.index], 'itemshown', [this]);\n            }\n\n            if (changed) {\n                this.prevIndex = prevIndex;\n                this.index = nextIndex;\n\n                !edge && trigger(prev, 'beforeitemhide', [this]);\n                trigger(next, 'beforeitemshow', [this]);\n            }\n\n            this._transitioner = this._translate(Math.abs(this.percent), prev, !edge && next);\n\n            if (changed) {\n                !edge && trigger(prev, 'itemhide', [this]);\n                trigger(next, 'itemshow', [this]);\n            }\n\n        },\n\n        end() {\n\n            event_off(window, 'scroll', this.unbindMove);\n            this.unbindMove && this.unbindMove();\n            event_off(document, pointerUp, this.end, true);\n\n            if (this.dragging) {\n\n                this.dragging = null;\n\n                if (this.index === this.prevIndex) {\n                    this.percent = 1 - this.percent;\n                    this.dir *= -1;\n                    this._show(false, this.index, true);\n                    this._transitioner = null;\n                } else {\n\n                    const dirChange = (isRtl ? this.dir * (isRtl ? 1 : -1) : this.dir) < 0 === this.prevPos > this.pos;\n                    this.index = dirChange ? this.index : this.prevIndex;\n\n                    if (dirChange) {\n                        this.percent = 1 - this.percent;\n                    }\n\n                    this.show(this.dir > 0 && !dirChange || this.dir < 0 && dirChange ? 'next' : 'previous', true);\n                }\n\n            }\n\n            style_css(this.list, {userSelect: '', pointerEvents: ''});\n\n            this.drag\n                = this.percent\n                = null;\n\n        }\n\n    }\n\n});\n\nfunction hasTextNodesOnly(el) {\n    return !el.children.length && el.childNodes.length;\n}\n\n// CONCATENATED MODULE: ./src/mixin/slider-nav.js\n\n\n/* harmony default export */ var slider_nav = ({\n\n    data: {\n        selNav: false\n    },\n\n    computed: {\n\n        nav({selNav}, $el) {\n            return dom_$(selNav, $el);\n        },\n\n        selNavItem({attrItem}) {\n            return `[${attrItem}],[data-${attrItem}]`;\n        },\n\n        navItems(_, $el) {\n            return $$(this.selNavItem, $el);\n        }\n\n    },\n\n    update: {\n\n        write() {\n\n            if (this.nav && this.length !== this.nav.children.length) {\n                dom_html(this.nav, this.slides.map((_, i) => `<li ${this.attrItem}=\"${i}\"><a href=\"#\"></a></li>`).join(''));\n            }\n\n            toggleClass($$(this.selNavItem, this.$el).concat(this.nav), 'jdb-hidden', !this.maxIndex);\n\n            this.updateNav();\n\n        },\n\n        events: ['resize']\n\n    },\n\n    events: [\n\n        {\n\n            name: 'click',\n\n            delegate() {\n                return this.selNavItem;\n            },\n\n            handler(e) {\n                e.preventDefault();\n                this.show(attr_data(e.current, this.attrItem));\n            }\n\n        },\n\n        {\n\n            name: 'itemshow',\n            handler: 'updateNav'\n\n        }\n\n    ],\n\n    methods: {\n\n        updateNav() {\n\n            const i = this.getValidIndex();\n            this.navItems.forEach(el => {\n\n                const cmd = attr_data(el, this.attrItem);\n\n                toggleClass(el, this.clsActive, Object(lang[\"toNumber\"])(cmd) === i);\n                toggleClass(el, 'jdb-invisible', this.finite && (cmd === 'previous' && i === 0 || cmd === 'next' && i >= this.maxIndex));\n            });\n\n        }\n\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/mixin/slider.js\n\n\n\n\n\n/* harmony default export */ var slider = ({\n\n    mixins: [slider_autoplay, slider_drag, slider_nav],\n\n    props: {\n        clsActivated: Boolean,\n        easing: String,\n        index: Number,\n        finite: Boolean,\n        velocity: Number\n    },\n\n    data: () => ({\n        easing: 'ease',\n        finite: false,\n        velocity: 1,\n        index: 0,\n        stack: [],\n        percent: 0,\n        clsActive: 'jdb-active',\n        clsActivated: false,\n        Transitioner: false,\n        transitionOptions: {}\n    }),\n\n    computed: {\n\n        duration({velocity}, $el) {\n            return speedUp($el.offsetWidth / velocity);\n        },\n\n        length() {\n            return this.slides.length;\n        },\n\n        list({selList}, $el) {\n            return dom_$(selList, $el);\n        },\n\n        maxIndex() {\n            return this.length - 1;\n        },\n\n        selSlides({selList}) {\n            return `${selList} > *`;\n        },\n\n        slides() {\n            return Object(lang[\"toNodes\"])(this.list.children);\n        }\n\n    },\n\n    events: {\n\n        itemshown() {\n            this.$update(this.list);\n        }\n\n    },\n\n    methods: {\n\n        show(index, force = false) {\n\n            if (this.dragging || !this.length) {\n                return;\n            }\n\n            const {stack} = this;\n            const queueIndex = force ? 0 : stack.length;\n            const reset = () => {\n                stack.splice(queueIndex, 1);\n\n                if (stack.length) {\n                    this.show(stack.shift(), true);\n                }\n            };\n\n            stack[force ? 'unshift' : 'push'](index);\n\n            if (!force && stack.length > 1) {\n\n                if (stack.length === 2) {\n                    this._transitioner.forward(Math.min(this.duration, 200));\n                }\n\n                return;\n            }\n\n            const prevIndex = this.index;\n            const prev = hasClass(this.slides, this.clsActive) && this.slides[prevIndex];\n            const nextIndex = this.getIndex(index, this.index);\n            const next = this.slides[nextIndex];\n\n            if (prev === next) {\n                reset();\n                return;\n            }\n\n            this.dir = getDirection(index, prevIndex);\n            this.prevIndex = prevIndex;\n            this.index = nextIndex;\n\n            prev && trigger(prev, 'beforeitemhide', [this]);\n            if (!trigger(next, 'beforeitemshow', [this, prev])) {\n                this.index = this.prevIndex;\n                reset();\n                return;\n            }\n\n            const promise = this._show(prev, next, force).then(() => {\n\n                prev && trigger(prev, 'itemhidden', [this]);\n                trigger(next, 'itemshown', [this]);\n\n                return new util_promise[\"Promise\"](resolve => {\n                    fastdom.write(() => {\n                        stack.shift();\n                        if (stack.length) {\n                            this.show(stack.shift(), true);\n                        } else {\n                            this._transitioner = null;\n                        }\n                        resolve();\n                    });\n                });\n\n            });\n\n            prev && trigger(prev, 'itemhide', [this]);\n            trigger(next, 'itemshow', [this]);\n\n            return promise;\n\n        },\n\n        getIndex(index = this.index, prev = this.index) {\n            return Object(lang[\"clamp\"])(getIndex(index, this.slides, prev, this.finite), 0, this.maxIndex);\n        },\n\n        getValidIndex(index = this.index, prevIndex = this.prevIndex) {\n            return this.getIndex(index, prevIndex);\n        },\n\n        _show(prev, next, force) {\n\n            this._transitioner = this._getTransitioner(\n                prev,\n                next,\n                this.dir,\n                Object(lang[\"assign\"])({\n                    easing: force\n                        ? next.offsetWidth < 600\n                            ? 'cubic-bezier(0.25, 0.46, 0.45, 0.94)' /* easeOutQuad */\n                            : 'cubic-bezier(0.165, 0.84, 0.44, 1)' /* easeOutQuart */\n                        : this.easing\n                }, this.transitionOptions)\n            );\n\n            if (!force && !prev) {\n                this._transitioner.translate(1);\n                return util_promise[\"Promise\"].resolve();\n            }\n\n            const {length} = this.stack;\n            return this._transitioner[length > 1 ? 'forward' : 'show'](length > 1 ? Math.min(this.duration, 75 + 75 / (length - 1)) : this.duration, this.percent);\n\n        },\n\n        _getDistance(prev, next) {\n            return new this._getTransitioner(prev, prev !== next && next).getDistance();\n        },\n\n        _translate(percent, prev = this.prevIndex, next = this.index) {\n            const transitioner = this._getTransitioner(prev !== next ? prev : false, next);\n            transitioner.translate(percent);\n            return transitioner;\n        },\n\n        _getTransitioner(prev = this.prevIndex, next = this.index, dir = this.dir || 1, options = this.transitionOptions) {\n            return new this.Transitioner(\n                Object(lang[\"isNumber\"])(prev) ? this.slides[prev] : prev,\n                Object(lang[\"isNumber\"])(next) ? this.slides[next] : next,\n                dir * (isRtl ? -1 : 1),\n                options\n            );\n        }\n\n    }\n\n});\n\nfunction getDirection(index, prevIndex) {\n    return index === 'next'\n        ? 1\n        : index === 'previous'\n            ? -1\n            : index < prevIndex\n                ? -1\n                : 1;\n}\n\nfunction speedUp(x) {\n    return .5 * x + 300; // parabola through (400,500; 600,600; 1800,1200)\n}\n\n// CONCATENATED MODULE: ./src/mixin/slider-reactive.js\n\n\n/* harmony default export */ var slider_reactive = ({\n\n    update: {\n\n        write() {\n\n            if (this.stack.length || this.dragging) {\n                return;\n            }\n\n            const index = this.getValidIndex();\n            delete this.index;\n            removeClass(this.slides, this.clsActive, this.clsActivated);\n            this.show(index);\n\n        },\n\n        events: ['resize']\n\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/mixin/internal/slideshow-animations.js\n\n\n/* harmony default export */ var slideshow_animations = ({\n\n    slide: {\n\n        show(dir) {\n            return [\n                {transform: slideshow_animations_translate(dir * -100)},\n                {transform: slideshow_animations_translate()}\n            ];\n        },\n\n        percent(current) {\n            return translated(current);\n        },\n\n        translate(percent, dir) {\n            return [\n                {transform: slideshow_animations_translate(dir * -100 * percent)},\n                {transform: slideshow_animations_translate(dir * 100 * (1 - percent))}\n            ];\n        }\n\n    }\n\n});\n\nfunction translated(el) {\n    return Math.abs(style_css(el, 'transform').split(',')[4] / el.offsetWidth) || 0;\n}\n\nfunction slideshow_animations_translate(value = 0, unit = '%') {\n    return `translateX(${value}${value ? unit : ''})`; // currently not translate3d to support IE, translate3d within translate3d does not work while transitioning\n}\n\nfunction scale3d(value) {\n    return `scale3d(${value}, ${value}, 1)`;\n}\n\n// CONCATENATED MODULE: ./src/components/internal/slider-transitioner.js\n\n\n\n/* harmony default export */ var slider_transitioner = (function (prev, next, dir, {center, easing, list}) {\n\n    const deferred = new util_promise[\"Deferred\"]();\n\n    const from = prev\n        ? getLeft(prev, list, center)\n        : getLeft(next, list, center) + bounds(next).width * dir;\n    const to = next\n        ? getLeft(next, list, center)\n        : from + bounds(prev).width * dir * (isRtl ? -1 : 1);\n\n    return {\n\n        dir,\n\n        show(duration, percent = 0, linear) {\n\n            const timing = linear ? 'linear' : easing;\n            duration -= Math.round(duration * Object(lang[\"clamp\"])(percent, -1, 1));\n\n            this.translate(percent);\n\n            prev && this.updateTranslates();\n            percent = prev ? percent : Object(lang[\"clamp\"])(percent, 0, 1);\n            triggerUpdate(this.getItemIn(), 'itemin', {percent, duration, timing, dir});\n            prev && triggerUpdate(this.getItemIn(true), 'itemout', {percent: 1 - percent, duration, timing, dir});\n\n            Transition\n                .start(list, {transform: slideshow_animations_translate(-to * (isRtl ? -1 : 1), 'px')}, duration, timing)\n                .then(deferred.resolve, lang[\"noop\"]);\n\n            return deferred.promise;\n\n        },\n\n        stop() {\n            return Transition.stop(list);\n        },\n\n        cancel() {\n            Transition.cancel(list);\n        },\n\n        reset() {\n            style_css(list, 'transform', '');\n        },\n\n        forward(duration, percent = this.percent()) {\n            Transition.cancel(list);\n            return this.show(duration, percent, true);\n        },\n\n        translate(percent) {\n\n            const distance = this.getDistance() * dir * (isRtl ? -1 : 1);\n\n            style_css(list, 'transform', slideshow_animations_translate(Object(lang[\"clamp\"])(\n                -to + (distance - distance * percent),\n                -getWidth(list),\n                bounds(list).width\n            ) * (isRtl ? -1 : 1), 'px'));\n\n            this.updateTranslates();\n\n            if (prev) {\n                percent = Object(lang[\"clamp\"])(percent, -1, 1);\n                triggerUpdate(this.getItemIn(), 'itemtranslatein', {percent, dir});\n                triggerUpdate(this.getItemIn(true), 'itemtranslateout', {percent: 1 - percent, dir});\n            }\n\n        },\n\n        percent() {\n            return Math.abs((style_css(list, 'transform').split(',')[4] * (isRtl ? -1 : 1) + from) / (to - from));\n        },\n\n        getDistance() {\n            return Math.abs(to - from);\n        },\n\n        getItemIn(out = false) {\n\n            const actives = this.getActives();\n            const all = Object(lang[\"sortBy\"])(slider_transitioner_slides(list), 'offsetLeft');\n            const i = dom_index(all, actives[dir * (out ? -1 : 1) > 0 ? actives.length - 1 : 0]);\n\n            return ~i && all[i + (prev && !out ? dir : 0)];\n\n        },\n\n        getActives() {\n\n            const left = getLeft(prev || next, list, center);\n\n            return Object(lang[\"sortBy\"])(slider_transitioner_slides(list).filter(slide => {\n                const slideLeft = getElLeft(slide, list);\n                return slideLeft >= left && slideLeft + bounds(slide).width <= bounds(list).width + left;\n            }), 'offsetLeft');\n\n        },\n\n        updateTranslates() {\n\n            const actives = this.getActives();\n\n            slider_transitioner_slides(list).forEach(slide => {\n                const isActive = Object(lang[\"includes\"])(actives, slide);\n\n                triggerUpdate(slide, `itemtranslate${isActive ? 'in' : 'out'}`, {\n                    percent: isActive ? 1 : 0,\n                    dir: slide.offsetLeft <= next.offsetLeft ? 1 : -1\n                });\n            });\n        }\n\n    };\n\n});\n\nfunction getLeft(el, list, center) {\n\n    const left = getElLeft(el, list);\n\n    return center\n        ? left - centerEl(el, list)\n        : Math.min(left, getMax(list));\n\n}\n\nfunction getMax(list) {\n    return Math.max(0, getWidth(list) - bounds(list).width);\n}\n\nfunction getWidth(list) {\n    return slider_transitioner_slides(list).reduce((right, el) => bounds(el).width + right, 0);\n}\n\nfunction getMaxWidth(list) {\n    return slider_transitioner_slides(list).reduce((right, el) => Math.max(right, bounds(el).width), 0);\n}\n\nfunction centerEl(el, list) {\n    return bounds(list).width / 2 - bounds(el).width / 2;\n}\n\nfunction getElLeft(el, list) {\n    return (dimensions_position(el).left + (isRtl ? bounds(el).width - bounds(list).width : 0)) * (isRtl ? -1 : 1);\n}\n\nfunction bounds(el) {\n    return el.getBoundingClientRect();\n}\n\nfunction triggerUpdate(el, type, data) {\n    trigger(el, createEvent(type, false, false, data));\n}\n\nfunction slider_transitioner_slides(list) {\n    return Object(lang[\"toNodes\"])(list.children);\n}\n\n// CONCATENATED MODULE: ./src/core/jdbp/slider.js\n\n\n\n\n\n\n/* harmony default export */ var jdbp_slider = ({\n\n    mixins: [mixin_class, slider, slider_reactive],\n\n    props: {\n        center: Boolean,\n        sets: Boolean,\n        ukey: String,\n    },\n\n    data: {\n        center: false,\n        sets: false,\n        attrItem: 'jdb-slider-item',\n        selList: '.jdb-slider-items',\n        selNav: '.jdb-slider-nav',\n        clsContainer: 'jdb-slider-container',\n        ukey: '',\n        Transitioner: slider_transitioner\n    },\n\n    computed: {\n\n        avgWidth() {\n            return getWidth(this.list) / this.length;\n        },\n\n        finite({\n            finite\n        }) {\n            return finite || getWidth(this.list) < bounds(this.list).width + getMaxWidth(this.list) + this.center;\n        },\n\n        maxIndex() {\n\n            if (!this.finite || this.center && !this.sets) {\n                return this.length - 1;\n            }\n\n            if (this.center) {\n                return this.sets[this.sets.length - 1];\n            }\n\n            style_css(this.slides, 'order', '');\n\n            const max = getMax(this.list);\n            let i = this.length;\n\n            while (i--) {\n                if (getElLeft(this.list.children[i], this.list) < max) {\n                    return Math.min(i + 1, this.length - 1);\n                }\n            }\n\n            return 0;\n        },\n\n        sets({\n            sets\n        }) {\n\n            const width = bounds(this.list).width / (this.center ? 2 : 1);\n\n            let left = 0;\n            let leftCenter = width;\n            let slideLeft = 0;\n\n            sets = sets && this.slides.reduce((sets, slide, i) => {\n\n                const {\n                    width: slideWidth\n                } = bounds(slide);\n                const slideRight = slideLeft + slideWidth;\n\n                if (slideRight > left) {\n\n                    if (!this.center && i > this.maxIndex) {\n                        i = this.maxIndex;\n                    }\n\n                    if (!Object(lang[\"includes\"])(sets, i)) {\n\n                        const cmp = this.slides[i + 1];\n                        if (this.center && cmp && slideWidth < leftCenter - bounds(cmp).width / 2) {\n                            leftCenter -= slideWidth;\n                        } else {\n                            leftCenter = width;\n                            sets.push(i);\n                            left = slideLeft + width + (this.center ? slideWidth / 2 : 0);\n                        }\n\n                    }\n                }\n\n                slideLeft += slideWidth;\n\n                return sets;\n\n            }, []);\n\n            return !Object(lang[\"isEmpty\"])(sets) && sets;\n\n        },\n\n        transitionOptions() {\n            return {\n                center: this.center,\n                list: this.list\n            };\n        }\n\n    },\n\n    connected() {\n        toggleClass(this.$el, this.clsContainer, !dom_$(`.${this.clsContainer}`, this.$el));\n    },\n\n    update: {\n\n        write() {\n\n            $$(`[${this.attrItem}],[data-${this.attrItem}]`, this.$el).forEach(el => {\n                const index = attr_data(el, this.attrItem);\n                this.maxIndex && toggleClass(el, 'jdb-hidden', Object(lang[\"isNumeric\"])(index) && (this.sets && !Object(lang[\"includes\"])(this.sets, Object(lang[\"toFloat\"])(index)) || index > this.maxIndex));\n            });\n\n        },\n\n        events: ['resize']\n\n    },\n\n    events: {\n\n        beforeitemshow(e) {\n\n            if (!this.dragging && this.sets && this.stack.length < 2 && !Object(lang[\"includes\"])(this.sets, this.index)) {\n                this.index = this.getValidIndex();\n            }\n\n            const diff = Math.abs(\n                this.index -\n                this.prevIndex +\n                (this.dir > 0 && this.index < this.prevIndex || this.dir < 0 && this.index > this.prevIndex ? (this.maxIndex + 1) * this.dir : 0)\n            );\n\n            if (!this.dragging && diff > 1) {\n\n                for (let i = 0; i < diff; i++) {\n                    this.stack.splice(1, 0, this.dir > 0 ? 'next' : 'previous');\n                }\n\n                e.preventDefault();\n                return;\n            }\n\n            this.duration = speedUp(this.avgWidth / this.velocity) *\n                (bounds(\n                    this.dir < 0 || !this.slides[this.prevIndex] ?\n                    this.slides[this.index] :\n                    this.slides[this.prevIndex]\n                ).width / this.avgWidth);\n\n            this.reorder();\n\n        },\n\n        itemshow() {\n            !Object(lang[\"isUndefined\"])(this.prevIndex) && addClass(this._getTransitioner().getItemIn(), this.clsActive);\n        },\n\n        itemshown() {\n            const actives = this._getTransitioner(this.index).getActives();\n            this.slides.forEach(slide => toggleClass(slide, this.clsActive, Object(lang[\"includes\"])(actives, slide)));\n            (!this.sets || Object(lang[\"includes\"])(this.sets, Object(lang[\"toFloat\"])(this.index))) && this.slides.forEach(slide => toggleClass(slide, this.clsActivated, Object(lang[\"includes\"])(actives, slide)));\n        }\n\n    },\n\n    methods: {\n\n        reorder() {\n\n            style_css(this.slides, 'order', '');\n\n            if (this.finite) {\n                return;\n            }\n\n            const index = this.dir > 0 && this.slides[this.prevIndex] ? this.prevIndex : this.index;\n\n            this.slides.forEach((slide, i) =>\n                style_css(slide, 'order', this.dir > 0 && i < index ?\n                    1 :\n                    this.dir < 0 && i >= this.index ?\n                    -1 :\n                    ''\n                )\n            );\n\n            if (!this.center) {\n                return;\n            }\n\n            const next = this.slides[index];\n            let width = bounds(this.list).width / 2 - bounds(next).width / 2;\n            let j = 0;\n\n            while (width > 0) {\n                const slideIndex = this.getIndex(--j + index, index);\n                const slide = this.slides[slideIndex];\n\n                style_css(slide, 'order', slideIndex > index ? -2 : -1);\n                width -= bounds(slide).width;\n            }\n\n        },\n\n        getValidIndex(index = this.index, prevIndex = this.prevIndex) {\n\n            index = this.getIndex(index, prevIndex);\n\n            if (!this.sets) {\n                return index;\n            }\n\n            let prev;\n\n            do {\n\n                if (Object(lang[\"includes\"])(this.sets, index)) {\n                    return index;\n                }\n\n                prev = index;\n                index = this.getIndex(index + this.dir, prevIndex);\n\n            } while (index !== prev);\n\n            return index;\n        }\n\n    }\n\n});\n// CONCATENATED MODULE: ./src/mixin/internal/slideshow-transitioner.js\n\n\nfunction Transitioner(prev, next, dir, {animation, easing}) {\n\n    const {percent, translate, show = lang[\"noop\"]} = animation;\n    const props = show(dir);\n    const deferred = new util_promise[\"Deferred\"]();\n\n    return {\n\n        dir,\n\n        show(duration, percent = 0, linear) {\n\n            const timing = linear ? 'linear' : easing;\n            duration -= Math.round(duration * Object(lang[\"clamp\"])(percent, -1, 1));\n\n            this.translate(percent);\n\n            slideshow_transitioner_triggerUpdate(next, 'itemin', {percent, duration, timing, dir});\n            slideshow_transitioner_triggerUpdate(prev, 'itemout', {percent: 1 - percent, duration, timing, dir});\n\n            util_promise[\"Promise\"].all([\n                Transition.start(next, props[1], duration, timing),\n                Transition.start(prev, props[0], duration, timing)\n            ]).then(() => {\n                this.reset();\n                deferred.resolve();\n            }, lang[\"noop\"]);\n\n            return deferred.promise;\n        },\n\n        stop() {\n            return Transition.stop([next, prev]);\n        },\n\n        cancel() {\n            Transition.cancel([next, prev]);\n        },\n\n        reset() {\n            for (const prop in props[0]) {\n                style_css([next, prev], prop, '');\n            }\n        },\n\n        forward(duration, percent = this.percent()) {\n            Transition.cancel([next, prev]);\n            return this.show(duration, percent, true);\n\n        },\n\n        translate(percent) {\n\n            this.reset();\n\n            const props = translate(percent, dir);\n            style_css(next, props[1]);\n            style_css(prev, props[0]);\n            slideshow_transitioner_triggerUpdate(next, 'itemtranslatein', {percent, dir});\n            slideshow_transitioner_triggerUpdate(prev, 'itemtranslateout', {percent: 1 - percent, dir});\n\n        },\n\n        percent() {\n            return percent(prev || next, next, dir);\n        },\n\n        getDistance() {\n            return prev && prev.offsetWidth;\n        }\n\n    };\n\n}\n\nfunction slideshow_transitioner_triggerUpdate(el, type, data) {\n    trigger(el, createEvent(type, false, false, data));\n}\n\n// CONCATENATED MODULE: ./src/mixin/slideshow.js\n\n\n\n\n\n/* harmony default export */ var slideshow = ({\n\n   mixins: [slider],\n\n   props: {\n      animation: String\n   },\n\n   data: {\n      animation: 'slide',\n      clsActivated: 'jdb-transition-active',\n      Animations: slideshow_animations,\n      Transitioner: Transitioner\n   },\n\n   computed: {\n\n      animation( {animation, Animations}) {\n         return Object(lang[\"assign\"])(animation in Animations ? Animations[animation] : Animations.slide, {name: animation});\n      },\n\n      transitionOptions() {\n         return {animation: this.animation};\n      }\n\n   },\n\n   events: {\n\n      'itemshow itemhide itemshown itemhidden'( {target}) {\n         this.$update(target);\n      },\n\n      itemshow() {\n         Object(lang[\"isNumber\"])(this.prevIndex) && fastdom.flush(); // iOS 10+ will honor the video.play only if called from a gesture handler\n      },\n\n      beforeitemshow( {target}) {\n         addClass(target, this.clsActive);\n      },\n\n      itemshown( {target}) {\n         addClass(target, this.clsActivated);\n      },\n\n      itemhidden( {target}) {\n         removeClass(target, this.clsActive, this.clsActivated);\n      }\n\n   }\n\n});\n\n// CONCATENATED MODULE: ./src/components/internal/slideshow-animations.js\n\n\n\n/* harmony default export */ var internal_slideshow_animations = (Object(lang[\"assign\"])({}, slideshow_animations, {\n\n    fade: {\n\n        show() {\n            return [\n                {opacity: 0, zIndex: 0},\n                {zIndex: -1}\n            ];\n        },\n\n        percent(current) {\n            return 1 - style_css(current, 'opacity');\n        },\n\n        translate(percent) {\n            return [\n                {opacity: 1 - percent, zIndex: 0},\n                {zIndex: -1}\n            ];\n        }\n\n    },\n\n    scale: {\n\n        show() {\n            return [\n                {opacity: 0, transform: scale3d(1 + .5), zIndex: 0},\n                {zIndex: -1}\n            ];\n        },\n\n        percent(current) {\n            return 1 - style_css(current, 'opacity');\n        },\n\n        translate(percent) {\n            return [\n                {opacity: 1 - percent, transform: scale3d(1 + .5 * percent), zIndex: 0},\n                {zIndex: -1}\n            ];\n        }\n\n    },\n\n    pull: {\n\n        show(dir) {\n            return dir < 0\n                ? [\n                    {transform: slideshow_animations_translate(30), zIndex: -1},\n                    {transform: slideshow_animations_translate(), zIndex: 0}\n                ]\n                : [\n                    {transform: slideshow_animations_translate(-100), zIndex: 0},\n                    {transform: slideshow_animations_translate(), zIndex: -1}\n                ];\n        },\n\n        percent(current, next, dir) {\n            return dir < 0\n                ? 1 - translated(next)\n                : translated(current);\n        },\n\n        translate(percent, dir) {\n            return dir < 0\n                ? [\n                    {transform: slideshow_animations_translate(30 * percent), zIndex: -1},\n                    {transform: slideshow_animations_translate(-100 * (1 - percent)), zIndex: 0}\n                ]\n                : [\n                    {transform: slideshow_animations_translate(-percent * 100), zIndex: 0},\n                    {transform: slideshow_animations_translate(30 * (1 - percent)), zIndex: -1}\n                ];\n        }\n\n    },\n\n    push: {\n\n        show(dir) {\n            return dir < 0\n                ? [\n                    {transform: slideshow_animations_translate(100), zIndex: 0},\n                    {transform: slideshow_animations_translate(), zIndex: -1}\n                ]\n                : [\n                    {transform: slideshow_animations_translate(-30), zIndex: -1},\n                    {transform: slideshow_animations_translate(), zIndex: 0}\n                ];\n        },\n\n        percent(current, next, dir) {\n            return dir > 0\n                ? 1 - translated(next)\n                : translated(current);\n        },\n\n        translate(percent, dir) {\n            return dir < 0\n                ? [\n                    {transform: slideshow_animations_translate(percent * 100), zIndex: 0},\n                    {transform: slideshow_animations_translate(-30 * (1 - percent)), zIndex: -1}\n                ]\n                : [\n                    {transform: slideshow_animations_translate(-30 * percent), zIndex: -1},\n                    {transform: slideshow_animations_translate(100 * (1 - percent)), zIndex: 0}\n                ];\n        }\n\n    }\n\n}));\n\n// CONCATENATED MODULE: ./src/core/jdbp/slideshow.js\n\n\n\n\n\n\n/* harmony default export */ var jdbp_slideshow = ({\n\n   mixins: [mixin_class, slideshow, slider_reactive],\n\n   props: {\n      ratio: String,\n      minHeight: Number,\n      maxHeight: Number\n   },\n\n   data: {\n      ratio: '16:9',\n      minHeight: false,\n      maxHeight: false,\n      selList: '.jdb-slideshow-items',\n      attrItem: 'jdb-slideshow-item',\n      selNav: '.jdb-slideshow-nav',\n      Animations: internal_slideshow_animations\n   },\n\n   update: {\n\n      read() {\n\n         let [width, height] = this.ratio.split(':').map(Number);\n\n         height = height * this.list.offsetWidth / width || 0;\n\n         if (this.minHeight) {\n            height = Math.max(this.minHeight, height);\n         }\n\n         if (this.maxHeight) {\n            height = Math.min(this.maxHeight, height);\n         }\n\n         return {\n            height: height - boxModelAdjust(this.list, 'content-box')\n         };\n      },\n\n      write({\n         height\n      }) {\n         style_css(this.list, 'minHeight', height);\n      },\n\n      events: ['resize']\n\n   }\n\n});\n// CONCATENATED MODULE: ./src/core/jdbp/animation.js\n\n\n/* harmony default export */ var jdbp_animation = ({\n\n   mixins: [mixin_class],\n\n   props: {\n      type: String,\n      speed: String,\n      delay: String,\n      infinite: Boolean,\n      preview: Boolean\n   },\n\n   data: {\n      type: '',\n      speed: '',\n      delay: '',\n      infinite: false,\n      preview: false\n   },\n\n   methods: {\n      init() {\n         let _el = this.$el;\n         removeClass(_el, 'animated');\n         [\"bounce\", \"flash\", \"pulse\", \"rubberBand\", \"shake\", \"swing\", \"tada\", \"wobble\", \"jello\", \"heartBeat\", \"bounceIn\", \"bounceInDown\", \"bounceInLeft\", \"bounceInRight\", \"bounceInUp\", \"fadeIn\", \"fadeInDown\", \"fadeInDownBig\", \"fadeInLeft\", \"fadeInLeftBig\", \"fadeInRight\", \"fadeInRightBig\", \"fadeInUp\", \"fadeInUpBig\", \"flip\", \"flipInX\", \"flipInY\", \"lightSpeedIn\", \"rotateIn\", \"rotateInDownLeft\", \"rotateInDownRight\", \"rotateInUpLeft\", \"rotateInUpRight\", \"slideInUp\", \"slideInDown\", \"slideInLeft\", \"slideInRight\", \"zoomIn\", \"zoomInDown\", \"zoomInLeft\", \"zoomInRight\", \"zoomInUp\", \"jackInTheBox\", \"rollIn\", \"slower\", \"slow\", \"fast\", \"faster\", \"infinite\", \"delay-1s\", \"delay-2s\", \"delay-3s\", \"delay-4s\", \"delay-5s\"].forEach(function (_animation) {\n            removeClass(_el, _animation);\n         });\n\n         this.animate();\n      },\n      animate() {\n         if (this.type == 'none') {\n            return false;\n         }\n\n         if (isInView(this.$el) && !hasClass(this.$el, 'animated')) {\n            if (this.type != '') {\n               addClass(this.$el, this.type);\n            }\n            if (this.speed != '') {\n               addClass(this.$el, this.speed);\n            }\n            if (this.delay != '') {\n               addClass(this.$el, this.delay);\n            }\n            if (this.infinite) {\n               addClass(this.$el, 'infinite');\n            }\n            if (this.type != '') {\n               addClass(this.$el, 'animated');\n            }\n         }\n      }\n   },\n\n   connected() {\n      this.init();\n   },\n\n   events: [{\n      name: 'scroll resize',\n      el: window,\n      handler() {\n         this.animate();\n      }\n   }],\n\n});\n// CONCATENATED MODULE: ./src/core/jdbp/animatedheading.js\n\n\n\n/* harmony default export */ var animatedheading = ({\n\n    mixins: [mixin_class],\n\n    props: {\n        before: String,\n        after: String,\n        texts: String,\n        tag: String,\n        link: String,\n        animation: String,\n        linkTargetBlank: Boolean,\n        linkNoFollow: Boolean,\n    },\n\n    data: {\n        before: '',\n        after: '',\n        texts: '',\n        tag: 'h3',\n        link: '',\n        animation: '',\n        linkTargetBlank: false,\n        linkNoFollow: false,\n    },\n\n    methods: {\n        init() {\n            empty(this.$el);\n            var texts = '';\n            if (this.link != '') {\n                texts += '<a href=\"' + this.link + '\"' + (this.linkTargetBlank ? ' target=\"_blank\"' : '') + '' + (this.linkNoFollow ? ' rel=\"nofollow\"' : '') + '>';\n            }\n            texts += '<' + this.tag + ' class=\"cd-headline ' + this.animation + '\">';\n            if (this.before != '') {\n                texts += '<span>' + decodeURI(this.before) + '</span>';\n            }\n            if (this.texts != '') {\n                texts += '<span class=\"cd-words-wrapper' + (this.animation == 'letters type' ? ' waiting' : '') + '\">';\n                var first = true;\n                this.texts.split(',').forEach(function (text) {\n                    texts += '<b' + (first ? ' class=\"is-visible\"' : '') + '>' + text + '</b>';\n                    first = false;\n                });\n                texts += '</span>';\n            }\n            if (this.after != '') {\n                texts += '<span>' + decodeURI(this.after) + '</span>';\n            }\n            texts += '</' + this.tag + '>';\n            if (this.link != '') {\n                texts += '</a>';\n            }\n            append(this.$el, texts);\n            if ($JDB(this.$el).children('.cd-headline').length) {\n                $JDB(this.$el).children('.cd-headline').JDAnimatedHeading();\n            } else {\n                $JDB(this.$el).children('a').children('.cd-headline').JDAnimatedHeading();\n            }\n        }\n    },\n\n    connected() {\n        this.init();\n    },\n\n});\n// CONCATENATED MODULE: ./src/core/jdbp/masonrygallery.js\n\n/* harmony default export */ var masonrygallery = ({\n\n    mixins: [mixin_class],\n\n    props: {\n        ukey: String,\n        selected: String,\n    },\n\n    data: {\n        ukey: '',\n        selected: '*',\n    },\n\n    methods: {\n        init() {\n            try {\n                $JDB(this.$el).justifiedGallery('destroy');\n                $JDB(this.$el).removeClass('jdb-justified-gallery');\n                $JDB(this.$el).isotope();\n                $JDB(this.$el).isotope('destroy');\n            } catch (e) {}\n\n            var _options = {\n                itemSelector: '.jdb-gallery-item',\n                layoutMode: 'masonry',\n                percentPosition: true,\n                masonry: {\n                    columnWidth: '.jdb-gallery-item'\n                }\n            };\n\n            var $grid = $JDB(this.$el).isotope(_options);\n            $JDB(this.$el).siblings('.jdb-gallery-filters').children('[data-filter]').unbind('click').bind('click', function () {\n                $JDB(this).siblings('button').removeClass('active');\n                $JDB(this).addClass('active');\n                var filterValue = $JDB(this).attr('data-filter');\n                $grid.isotope({\n                    filter: filterValue\n                });\n            });\n\n            if (this.selected != '' && this.selected != '*') {\n                if ($JDB(this.$el).siblings('.jdb-gallery-filters').children('[data-filter=\"' + ('.jdb-gallery-item-' + this.selected.toLowerCase()) + '\"]') !== undefined) {\n                    $JDB(this.$el).siblings('.jdb-gallery-filters').children('[data-filter=\"' + ('.jdb-gallery-item-' + this.selected.toLowerCase()) + '\"]').trigger('click');\n                }\n            } else {\n                $JDB(this.$el).siblings('.jdb-gallery-filters').children('[data-filter=\"*\"]').trigger('click');\n            }\n        },\n        refresh() {\n            try {\n                $JDB(this.$el).isotope('reloadItems').isotope({\n                    sortBy: 'original-order'\n                });\n            } catch (e) {}\n        }\n    },\n\n    connected() {\n        this.init();\n    },\n\n    events: [{\n        name: 'load',\n        el: window,\n        handler() {\n            this.refresh();\n        }\n    }]\n\n});\n// CONCATENATED MODULE: ./src/core/jdbp/justifygallery.js\n\n/* harmony default export */ var justifygallery = ({\n\n    mixins: [mixin_class],\n\n    props: {\n        ukey: String,\n        rowHeight: Number,\n        gridGap: Number,\n    },\n\n    data: {\n        ukey: '',\n        rowHeight: 200,\n        gridGap: 10\n    },\n\n    methods: {\n        init() {\n            try {\n                $JDB(this.$el).justifiedGallery('destroy');\n                $JDB(this.$el).removeClass('jdb-justified-gallery');\n                $JDB(this.$el).isotope();\n                $JDB(this.$el).isotope('destroy');\n                $JDB(this.$el).removeClass('jdb-masonry-gallery');\n            } catch (e) {}\n            var rowHeight = this.rowHeight;\n            var gridGap = this.gridGap;\n            $JDB(this.$el).justifiedGallery({\n                rowHeight: rowHeight,\n                margins: gridGap,\n            });\n        }\n    },\n\n    connected() {\n        this.init();\n    }\n\n});\n// CONCATENATED MODULE: ./src/core/jdbp/gridgallery.js\n\n/* harmony default export */ var gridgallery = ({\n\n    mixins: [mixin_class],\n\n    props: {\n        ukey: String\n    },\n\n    data: {\n        ukey: ''\n    },\n\n    methods: {\n        init() {\n            try {\n                $JDB(this.$el).justifiedGallery('destroy');\n                $JDB(this.$el).isotope();\n                $JDB(this.$el).isotope('destroy');\n            } catch (e) {}\n            $JDB(this.$el).removeClass('jdb-masonry-gallery');\n            $JDB(this.$el).removeClass('jdb-justified-gallery');\n            $JDB(this.$el).removeAttr('style');\n            $JDB(this.$el).children('.jdb-gallery-item').removeAttr('style');\n        }\n    },\n\n    connected() {\n        this.init();\n    }\n\n});\n// CONCATENATED MODULE: ./src/core/jdbp/particles.js\n\n\n/* harmony default export */ var particles = ({\n    mixins: [mixin_class],\n\n    props: {\n        count: Number,\n        size: Number,\n        shape: String,\n        color: String,\n        opacity: Number,\n        hover: Boolean,\n        hoverMode: String,\n        lines: Boolean,\n        linesDistance: Number,\n        linesColor: String,\n        linesOpacity: Number,\n        linesWidth: Number,\n        moveSpeed: Number,\n        moveDirection: String\n    },\n\n    data: {\n        count: 80,\n        size: 10,\n        shape: 'circle',\n        color: '#ffffff',\n        opacity: 50,\n        hover: true,\n        hoverMode: 'repulse',\n        lines: true,\n        linesDistance: 150,\n        linesColor: '#ffffff',\n        linesOpacity: 40,\n        linesWidth: 1,\n        moveSpeed: 12,\n        moveDirection: 'none'\n    },\n\n    methods: {\n        init() {\n\n            if (window[\"pJSDom\"] === null) {\n                window[\"pJSDom\"] = [];\n            }\n\n            var id = attr_data(this.$el, 'id');\n            id += '-particle-bg';\n            attr_attr(this.$el, 'id', id);\n\n            var options = {\n                \"particles\": {\n                    \"number\": {\n                        \"value\": this.count,\n                        \"density\": {\n                            \"enable\": true,\n                            \"value_area\": 800\n                        }\n                    },\n                    \"color\": {\n                        \"value\": this.color\n                    },\n                    \"shape\": {\n                        \"type\": this.shape,\n                        \"stroke\": {\n                            \"width\": 0,\n                            \"color\": \"#000000\"\n                        },\n                        \"polygon\": {\n                            \"nb_sides\": 5\n                        },\n                        \"image\": {\n                            \"src\": \"img/github.svg\",\n                            \"width\": 100,\n                            \"height\": 100\n                        }\n                    },\n                    \"opacity\": {\n                        \"value\": (this.opacity / 100),\n                        \"random\": false,\n                        \"anim\": {\n                            \"enable\": false,\n                            \"speed\": 1,\n                            \"opacity_min\": 0.1,\n                            \"sync\": false\n                        }\n                    },\n                    \"size\": {\n                        \"value\": this.size,\n                        \"random\": true,\n                        \"anim\": {\n                            \"enable\": false,\n                            \"speed\": 80,\n                            \"size_min\": 0.1,\n                            \"sync\": false\n                        }\n                    },\n                    \"line_linked\": {\n                        \"enable\": this.lines,\n                        \"distance\": this.linesDistance,\n                        \"color\": this.linesColor,\n                        \"opacity\": (this.linesOpacity / 100),\n                        \"width\": this.linesWidth\n                    },\n                    \"move\": {\n                        \"enable\": true,\n                        \"speed\": this.moveSpeed,\n                        \"direction\": this.moveDirection,\n                        \"random\": false,\n                        \"straight\": false,\n                        \"out_mode\": \"out\",\n                        \"bounce\": false,\n                        \"attract\": {\n                            \"enable\": false,\n                            \"rotateX\": 600,\n                            \"rotateY\": 1200\n                        }\n                    }\n                },\n                \"interactivity\": {\n                    \"detect_on\": \"canvas\",\n                    \"events\": {\n                        \"onhover\": {\n                            \"enable\": false,\n                            \"mode\": 'repulse'\n                        },\n                        \"onclick\": {\n                            \"enable\": true,\n                            \"mode\": \"push\"\n                        },\n                        \"resize\": true\n                    },\n                    \"modes\": {\n                        \"grab\": {\n                            \"distance\": this.linesDistance,\n                            \"line_linked\": {\n                                \"opacity\": (this.linesOpacity / 100)\n                            }\n                        },\n                        \"bubble\": {\n                            \"distance\": 800,\n                            \"size\": (this.size * 1.5),\n                            \"duration\": 2,\n                            \"opacity\": (this.opacity / 100) * 1.5,\n                            \"speed\": 3\n                        },\n                        \"repulse\": {\n                            \"distance\": 400,\n                            \"duration\": 0.4\n                        },\n                        \"push\": {\n                            \"particles_nb\": 4\n                        },\n                        \"remove\": {\n                            \"particles_nb\": 2\n                        }\n                    }\n                },\n                \"retina_detect\": true\n            };\n\n            particlesJS(id, options);\n\n        }\n    },\n\n    created() {\n        if (!hasAttr(this.$el, 'data-inpreview')) {\n            var _this = this;\n            setTimeout(function () {\n                _this.init();\n            }, 200);\n        }\n    }\n});\n// CONCATENATED MODULE: ./src/core/jdbp/gmap.js\n\n\n/* harmony default export */ var gmap = ({\n    mixins: [mixin_class],\n\n    props: {\n        count: Number,\n        size: Number,\n        shape: String,\n        color: String,\n        opacity: Number,\n        hover: Boolean,\n        hoverMode: String,\n        lines: Boolean,\n        linesDistance: Number,\n        linesColor: String,\n        linesOpacity: Number,\n        linesWidth: Number,\n        moveSpeed: Number,\n        moveDirection: String\n    },\n\n    data: {\n        count: 80,\n        size: 10,\n        shape: 'circle',\n        color: '#ffffff',\n        opacity: 50,\n        hover: true,\n        hoverMode: 'repulse',\n        lines: true,\n        linesDistance: 150,\n        linesColor: '#ffffff',\n        linesOpacity: 40,\n        linesWidth: 1,\n        moveSpeed: 12,\n        moveDirection: 'none'\n    },\n\n    methods: {\n        init() {\n            style_css(this.$el, 'height', '300px');\n            new google.maps.Map(this.$el, {\n                center: {\n                    lat: -34.397,\n                    lng: 150.644\n                },\n                zoom: 8\n            });\n        }\n    },\n\n    connected() {\n        this.init();\n    }\n});\n// CONCATENATED MODULE: ./src/core/jdbp/video.js\n\n\n\n/* harmony default export */ var jdbp_video = ({\n    // mixins: [Class],\n\n    props: {\n        type: String,\n        thumbnail: Boolean,\n        thumbnailSize: String,\n        controls: Boolean,\n        autoplay: Boolean,\n        muted: Boolean,\n        loop: Boolean,\n        sticky: Boolean,\n        stickyPosition: String,\n        poster: String,\n        ukey: String,\n        overlay: String,\n        size: String,\n        start: Number,\n        end: Number,\n        ytmb: Boolean,\n        ytpm: Boolean,\n        ytsv: Boolean,\n        animation: String,\n        lightbox: String,\n        hideOn: String\n    },\n\n    data: {\n        type: 'html5',\n        thumbnail: false,\n        thumbnailSize: 'maxresdefault',\n        controls: true,\n        autoplay: false,\n        muted: false,\n        loop: false,\n        sticky: false,\n        stickyPosition: 'bottom-right',\n        poster: '',\n        ukey: '',\n        overlay: '',\n        size: '',\n        start: 0,\n        end: 0,\n        ytmb: false,\n        ytpm: false,\n        ytsv: false,\n        animation: '',\n        lightbox: '',\n        hideOn: ''\n    },\n\n    methods: {\n        init() {\n            empty(this.$el);\n            var $video = document.createElement('div');\n            $video.setAttribute('id', uniqueid('jdb-video-'));\n            this.$el.appendChild($video);\n\n            var src = attr_data(this.$el, 'src');\n            if (src == '') {\n                return false;\n            }\n\n            var thumbnail = false;\n            if (this.thumbnail) {\n                if (attr_data(this.$el, 'thumbnail') != '') {\n                    thumbnail = attr_data(this.$el, 'thumbnail');\n                }\n            }\n\n            if (thumbnail == false && this.type == 'youtube') {\n                thumbnail = '';\n            }\n\n            /* if(thumbnail == false && this.type == 'vimeo'){\n                thumbnail = '';\n            } */\n\n            const stickyClass = [];\n\n            this.hideOn.split('-').forEach(function (_hideOn) {\n                if (_hideOn != '') {\n                    stickyClass.push('jdb-video-sticky-hide-' + _hideOn);\n                }\n            });\n\n            const _options = {};\n            _options.prefix = 'jdb';\n            _options.type = this.type;\n            _options.src = src;\n            _options.controls = this.controls;\n            _options.autoplay = this.autoplay;\n            _options.loop = this.loop;\n            _options.muted = this.muted;\n            _options.thumbnail = thumbnail;\n            _options.sticky = this.sticky;\n            _options.stickyPosition = this.stickyPosition;\n            _options.stickyClass = stickyClass.join(' ');\n            _options.overlay = this.overlay;\n            _options.size = this.size;\n            _options.thumbnailSize = this.thumbnailSize;\n\n            if (this.type == 'youtube') {\n                var _youtube = {};\n                if (this.start != 0) {\n                    _youtube.start = this.start;\n                }\n                if (this.end != 0 && this.start < this.end) {\n                    _youtube.end = this.end;\n                }\n                if (this.ytmb) {\n                    _youtube.modestbranding = 1;\n                }\n\n                if (this.ytpm) {\n                    _options.host = 'https://www.youtube-nocookie.com';\n                }\n\n                if (this.ytsv) {\n                    _youtube.rel = 1;\n                }\n\n                _options.youtube = _youtube;\n            }\n\n            if (this.type == 'vimeo') {\n                var _vimeo = JSON.parse(attr_data(this.$el, 'vimeo'));\n                _options.vimeo = _vimeo;\n            }\n\n            if (this.type == 'dailymotion') {\n                var _dailymotion = JSON.parse(attr_data(this.$el, 'dailymotion'));\n                _options.dailymotion = _dailymotion;\n            }\n\n            _options.animation = this.animation;\n\n            var play = attr_data(this.$el, 'play');\n\n            _options.icon = '<svg aria-hidden=\"true\" focusable=\"false\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"><path fill=\"currentColor\" d=\"M371.7 238l-176-107c-15.8-8.8-35.7 2.5-35.7 21v208c0 18.4 19.8 29.8 35.7 21l176-101c16.4-9.1 16.4-32.8 0-42zM504 256C504 119 393 8 256 8S8 119 8 256s111 248 248 248 248-111 248-248zm-448 0c0-110.5 89.5-200 200-200s200 89.5 200 200-89.5 200-200 200S56 366.5 56 256z\" class=\"\"></path></svg>';\n\n\n            if (thumbnail == '' && this.type == 'youtube') {\n                play = '';\n                _options.icon = '<?xml version=\"1.0\" encoding=\"UTF-8\"?><svg enable-background=\"new 0 0 1024 721\" version=\"1.1\" viewBox=\"0 0 1024 721\" xml:space=\"preserve\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"m407 493 276-143-276-144v287z\" fill=\"#fff\"/><path d=\"m407 206 242 161.6 34-17.6-276-144z\" fill=\"#420000\" opacity=\".12\"/><linearGradient id=\"a\" x1=\"512.5\" x2=\"512.5\" y1=\"719.7\" y2=\"1.2\" gradientTransform=\"matrix(1 0 0 -1 0 721)\" gradientUnits=\"userSpaceOnUse\"><stop stop-color=\"#E52D27\" offset=\"0\"/><stop stop-color=\"#BF171D\" offset=\"1\"/></linearGradient><path d=\"m1013 156.3s-10-70.4-40.6-101.4c-38.8-40.7-82.4-40.9-102.3-43.3-143-10.3-357.4-10.3-357.4-10.3h-0.4s-214.4 0-357.4 10.3c-19.9 2.4-63.5 2.6-102.3 43.3-30.6 31-40.6 101.4-40.6 101.4s-10.2 82.6-10.2 165.3v77.5c0 82.7 10.2 165.3 10.2 165.3s10 70.4 40.6 101.4c38.9 40.7 89.9 39.4 112.6 43.7 81.7 7.8 347.3 10.3 347.3 10.3s214.6-0.3 357.6-10.7c20-2.4 63.5-2.6 102.3-43.3 30.6-31 40.6-101.4 40.6-101.4s10.2-82.7 10.2-165.3v-77.5c0-82.7-10.2-165.3-10.2-165.3zm-606 336.7v-287l276 144-276 143z\" fill=\"url(#a)\"/></svg>';\n            }\n\n            switch (play) {\n                case 'icon':\n                    var icon = attr_data(this.$el, 'play-icon');\n                    if (icon != '') {\n                        _options.icon = '<span class=\"' + icon + '\" />';\n                    }\n                    break;\n                case 'image':\n                    var image = attr_data(this.$el, 'play-image');\n                    if (image != '') {\n                        _options.icon = '<img src=\"' + image + '\" />';\n                    }\n                    break;\n                case 'none':\n                    _options.icon = '';\n                    _options.animation = '';\n                    break;\n            }\n\n            /* if(thumbnail == '' && this.type == 'vimeo'){\n                _options.icon = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\"><path d=\"M3 22v-20l18 10-18 10z\"/></svg>';\n            } */\n\n            if (this.lightbox != '') {\n                _options.lightbox = this.lightbox;\n            }\n\n            this.$player = new window.jdVideo($video, _options);\n        }\n    },\n\n    /* update: {\n        write() {\n            try {\n                this.$player.destroy();\n                this.init();\n            } catch (e) {}\n        }\n    }, */\n\n    connected() {\n        this.init();\n    },\n    \n    disconnected() {\n        this.$player.destroy();\n    }\n});\n// CONCATENATED MODULE: ./src/core/jdbp/videoBackground.js\n\n\n\n/* harmony default export */ var videoBackground = ({\n    mixins: [mixin_class],\n\n    props: {\n        key: String\n    },\n\n    data: {\n        key: ''\n    },\n\n    methods: {\n        init() {\n            this.destroy();\n            var src = attr_data(this.$el, 'src');\n            var $video = document.createElement('video');\n            $video.loop = true;\n            $video.muted = true;\n            $video.src = src;\n            $video.autoplay = true;\n            $video.controls = false;\n            this.$video = $video;\n            this.$el.appendChild($video);\n        },\n        destroy() {\n            while (this.$el.firstChild) {\n                this.$el.removeChild(this.$el.firstChild);\n            }\n        }\n    },\n\n    connected() {\n        this.init();\n    },\n\n    disconnected() {\n        this.destroy();\n    }\n});\n// CONCATENATED MODULE: ./src/core/jdbp/ytsubscribe.js\n\n\n\n/* harmony default export */ var ytsubscribe = ({\n    mixins: [mixin_class],\n\n    props: {\n        channel: String,\n        channelid: String,\n        layout: String,\n        count: String,\n        theme: String\n    },\n\n    data: {\n        channel: '',\n        channelid: '',\n        layout: 'default',\n        count: 'default',\n        theme: '',\n        focused: false\n    },\n\n    methods: {\n        init() {\n            empty(this.$el);\n\n            var $div = document.createElement('div');\n            this.$el.appendChild($div);\n\n            const _options = {};\n\n            _options.prefix = 'jdb';\n            if (this.channelid != '') {\n                _options.channelid = this.channelid;\n            } else {\n                _options.channel = this.channel;\n            }\n\n            if (this.layout !== '') {\n                _options.layout = this.layout;\n            }\n            if (this.count !== '') {\n                _options.count = this.count;\n            }\n            if (this.theme !== '') {\n                _options.theme = this.theme;\n            }\n\n            new window.jdYtSubscriber($div, _options);\n        }\n    },\n\n    connected() {\n        this.init();\n    }\n});\n// CONCATENATED MODULE: ./src/core/jdbp/progressbar.js\n\n\n/* harmony default export */ var progressbar = ({\n\n    mixins: [mixin_class],\n\n    props: {\n        label: String,\n        value: Number,\n        type: String,\n        height: Number,\n        position: String,\n        displayLabels: Boolean,\n        displayPercentageLabels: Boolean,\n        striped: Boolean,\n        animation: Boolean,\n    },\n\n    data: {\n        label: '',\n        value: 0,\n        type: 'default',\n        height: 30,\n        position: 'inside',\n        displayLabels: true,\n        displayPercentageLabels: true,\n        striped: false,\n        animation: false,\n    },\n\n    methods: {\n        init() {\n\n            attr_attr(this.$el, 'data-type', this.type);\n            attr_attr(this.$el, 'data-position', this.position);\n\n            let striped = 'none';\n            if (this.striped) {\n                striped = this.animation ? 'animated' : 'normal';\n            }\n            attr_attr(this.$el, 'data-striped', striped);\n\n            style_css(this.$el, 'height', this.height + 'px');\n            if (this.position == 'outside' && (this.displayLabels || this.displayPercentageLabels)) {\n                style_css(this.$el, 'margin-top', (this.height + 10) + 'px');\n            } else {\n                style_css(this.$el, 'margin-top', '0px');\n            }\n\n            var prograss = $JDB('.jdb-progressbar-progress', this.$el);\n            style_css(prograss, 'width', this.value + '%');\n\n            var labels = $JDB('.jdb-progressbar-labels', this.$el);\n            remove(labels);\n\n            if (this.displayLabels || this.displayPercentageLabels) {\n                const labels = document.createElement('div');\n                addClass(labels, 'jdb-progressbar-labels');\n                if (this.position == 'outside') {\n                    style_css(labels, 'width', '100%');\n                } else {\n                    style_css(labels, 'min-width', this.value + '%');\n                    style_css(labels, 'line-height', this.height + 'px');\n                }\n\n                if (this.displayLabels) {\n                    const label = document.createElement('span');\n                    label.textContent = this.label;\n                    addClass(label, 'jdb-label');\n                    append(labels, label);\n                }\n\n                if (this.displayPercentageLabels) {\n                    const value = document.createElement('span');\n                    value.textContent = this.value + '%';\n                    addClass(value, 'jdb-value');\n                    append(labels, value);\n                }\n\n                append(this.$el, labels);\n            }\n        }\n    },\n\n    connected() {\n        this.init();\n    },\n\n    events: [{\n        name: 'scroll resize',\n        el: window,\n        handler() {\n            // this.init();\n        }\n    }],\n\n});\n// CONCATENATED MODULE: ./node_modules/countup.js/dist/countUp.min.js\nvar __assign=undefined&&undefined.__assign||function(){return(__assign=Object.assign||function(t){for(var i,a=1,s=arguments.length;a<s;a++)for(var n in i=arguments[a])Object.prototype.hasOwnProperty.call(i,n)&&(t[n]=i[n]);return t}).apply(this,arguments)},CountUp=function(){function t(t,i,a){var s=this;this.target=t,this.endVal=i,this.options=a,this.version=\"2.0.4\",this.defaults={startVal:0,decimalPlaces:0,duration:2,useEasing:!0,useGrouping:!0,smartEasingThreshold:999,smartEasingAmount:333,separator:\",\",decimal:\".\",prefix:\"\",suffix:\"\"},this.finalEndVal=null,this.useEasing=!0,this.countDown=!1,this.error=\"\",this.startVal=0,this.paused=!0,this.count=function(t){s.startTime||(s.startTime=t);var i=t-s.startTime;s.remaining=s.duration-i,s.useEasing?s.countDown?s.frameVal=s.startVal-s.easingFn(i,0,s.startVal-s.endVal,s.duration):s.frameVal=s.easingFn(i,s.startVal,s.endVal-s.startVal,s.duration):s.countDown?s.frameVal=s.startVal-(s.startVal-s.endVal)*(i/s.duration):s.frameVal=s.startVal+(s.endVal-s.startVal)*(i/s.duration),s.countDown?s.frameVal=s.frameVal<s.endVal?s.endVal:s.frameVal:s.frameVal=s.frameVal>s.endVal?s.endVal:s.frameVal,s.frameVal=Math.round(s.frameVal*s.decimalMult)/s.decimalMult,s.printValue(s.frameVal),i<s.duration?s.rAF=requestAnimationFrame(s.count):null!==s.finalEndVal?s.update(s.finalEndVal):s.callback&&s.callback()},this.formatNumber=function(t){var i,a,n,e,r,o=t<0?\"-\":\"\";if(i=Math.abs(t).toFixed(s.options.decimalPlaces),n=(a=(i+=\"\").split(\".\"))[0],e=a.length>1?s.options.decimal+a[1]:\"\",s.options.useGrouping){r=\"\";for(var l=0,h=n.length;l<h;++l)0!==l&&l%3==0&&(r=s.options.separator+r),r=n[h-l-1]+r;n=r}return s.options.numerals&&s.options.numerals.length&&(n=n.replace(/[0-9]/g,function(t){return s.options.numerals[+t]}),e=e.replace(/[0-9]/g,function(t){return s.options.numerals[+t]})),o+s.options.prefix+n+e+s.options.suffix},this.easeOutExpo=function(t,i,a,s){return a*(1-Math.pow(2,-10*t/s))*1024/1023+i},this.options=__assign({},this.defaults,a),this.formattingFn=this.options.formattingFn?this.options.formattingFn:this.formatNumber,this.easingFn=this.options.easingFn?this.options.easingFn:this.easeOutExpo,this.startVal=this.validateValue(this.options.startVal),this.frameVal=this.startVal,this.endVal=this.validateValue(i),this.options.decimalPlaces=Math.max(this.options.decimalPlaces),this.decimalMult=Math.pow(10,this.options.decimalPlaces),this.resetDuration(),this.options.separator=String(this.options.separator),this.useEasing=this.options.useEasing,\"\"===this.options.separator&&(this.options.useGrouping=!1),this.el=\"string\"==typeof t?document.getElementById(t):t,this.el?this.printValue(this.startVal):this.error=\"[CountUp] target is null or undefined\"}return t.prototype.determineDirectionAndSmartEasing=function(){var t=this.finalEndVal?this.finalEndVal:this.endVal;this.countDown=this.startVal>t;var i=t-this.startVal;if(Math.abs(i)>this.options.smartEasingThreshold){this.finalEndVal=t;var a=this.countDown?1:-1;this.endVal=t+a*this.options.smartEasingAmount,this.duration=this.duration/2}else this.endVal=t,this.finalEndVal=null;this.finalEndVal?this.useEasing=!1:this.useEasing=this.options.useEasing},t.prototype.start=function(t){this.error||(this.callback=t,this.duration>0?(this.determineDirectionAndSmartEasing(),this.paused=!1,this.rAF=requestAnimationFrame(this.count)):this.printValue(this.endVal))},t.prototype.pauseResume=function(){this.paused?(this.startTime=null,this.duration=this.remaining,this.startVal=this.frameVal,this.determineDirectionAndSmartEasing(),this.rAF=requestAnimationFrame(this.count)):cancelAnimationFrame(this.rAF),this.paused=!this.paused},t.prototype.reset=function(){cancelAnimationFrame(this.rAF),this.paused=!0,this.resetDuration(),this.startVal=this.validateValue(this.options.startVal),this.frameVal=this.startVal,this.printValue(this.startVal)},t.prototype.update=function(t){cancelAnimationFrame(this.rAF),this.startTime=null,this.endVal=this.validateValue(t),this.endVal!==this.frameVal&&(this.startVal=this.frameVal,this.finalEndVal||this.resetDuration(),this.determineDirectionAndSmartEasing(),this.rAF=requestAnimationFrame(this.count))},t.prototype.printValue=function(t){var i=this.formattingFn(t);\"INPUT\"===this.el.tagName?this.el.value=i:\"text\"===this.el.tagName||\"tspan\"===this.el.tagName?this.el.textContent=i:this.el.innerHTML=i},t.prototype.ensureNumber=function(t){return\"number\"==typeof t&&!isNaN(t)},t.prototype.validateValue=function(t){var i=Number(t);return this.ensureNumber(i)?i:(this.error=\"[CountUp] invalid start or end value: \"+t,null)},t.prototype.resetDuration=function(){this.startTime=null,this.duration=1e3*Number(this.options.duration),this.remaining=this.duration},t}();\n// CONCATENATED MODULE: ./src/core/jdbp/counter.js\n\n\n\n/* harmony default export */ var counter = ({\n    mixins: [mixin_class],\n\n    props: {\n        start: Number,\n        end: Number,\n        separator: String,\n        decimalPlaces: Number,\n        duration: Number\n    },\n\n    data: {\n        start: 0,\n        end: 0,\n        separator: '',\n        decimalPlaces: 0,\n        duration: 2000,\n        countup: null\n    },\n\n    methods: {\n        init() {\n\n            empty(this.$el);\n            removeClass(this.$el, 'jdb-animation-done');\n\n            const span = document.createElement('span');\n            append(this.$el, span);\n\n            var sep = '';\n            switch (this.separator) {\n                case 'comma':\n                    sep = ',';\n                    break;\n                case 'dot':\n                    sep = '.';\n                    break;\n            }\n\n            this.countup = new CountUp(span, this.end, {\n                startVal: this.start,\n                decimalPlaces: this.decimalPlaces,\n                duration: (this.duration / 1000),\n                separator: sep\n            });\n        },\n        animate() {\n            if (isInView(this.$el) && !hasClass(this.$el, 'jdb-animation-done')) {\n                addClass(this.$el, 'jdb-animation-done');\n                this.countup.start();\n            }\n        }\n    },\n    connected() {\n        this.init();\n        this.animate();\n    },\n    events: [{\n        name: 'scroll resize',\n        el: window,\n        handler() {\n            this.animate();\n        }\n    }],\n});\n// CONCATENATED MODULE: ./src/core/jdbp/countdown.js\n\n\n\n// import pluralize from 'pluralize';\n\n\n/* harmony default export */ var countdown = ({\n\n    mixins: [mixin_class],\n\n    props: {\n        date: String,\n        after: String,\n        redirect: String,\n        wait: Number,\n        preview: Boolean,\n    },\n\n    data: {\n        date: '',\n        clsWrapper: '.jdb-countdown-%unit%',\n        after: 'hide',\n        redirect: '',\n        wait: 3000,\n        preview: false,\n    },\n\n    computed: {\n\n        date({\n            date\n        }) {\n            return Date.parse(date);\n        },\n\n        days({\n            clsWrapper\n        }, $el) {\n            return dom_$(clsWrapper.replace('%unit%', 'days'), $el);\n        },\n\n        hours({\n            clsWrapper\n        }, $el) {\n            return dom_$(clsWrapper.replace('%unit%', 'hours'), $el);\n        },\n\n        minutes({\n            clsWrapper\n        }, $el) {\n            return dom_$(clsWrapper.replace('%unit%', 'minutes'), $el);\n        },\n\n        seconds({\n            clsWrapper\n        }, $el) {\n            return dom_$(clsWrapper.replace('%unit%', 'seconds'), $el);\n        },\n\n        units() {\n            return ['days', 'hours', 'minutes', 'seconds'].filter(unit => this[unit]);\n        }\n\n    },\n\n    connected() {\n        this.start();\n        this.check();\n        this.redirectionDone = false;\n    },\n\n    disconnected() {\n        this.stop();\n        this.units.forEach(unit => empty(this[unit]));\n    },\n\n    events: [\n\n        {\n\n            name: 'visibilitychange',\n\n            el: document,\n\n            handler() {\n                if (document.hidden) {\n                    this.stop();\n                } else {\n                    this.start();\n                }\n            }\n\n        }\n\n    ],\n\n    update: {\n\n        write() {\n\n            const timespan = getTimeSpan(this.date);\n\n            if (timespan.total <= 0) {\n\n                this.stop();\n\n                timespan.days = timespan.hours = timespan.minutes = timespan.seconds = 0;\n            }\n\n            this.units.forEach(unit => {\n\n                let digits = String(Math.floor(timespan[unit]));\n\n                const sing = Math.floor(timespan[unit]) == 1 ? true : false;\n\n                digits = digits.length < 2 ? `0${digits}` : digits;\n\n                const el = this[unit];\n                if (el.textContent !== digits) {\n                    digits = digits.split('');\n\n                    if (digits.length !== el.children.length) {\n                        dom_html(el, digits.map(() => '<span></span>').join(''));\n                    }\n\n                    digits.forEach((digit, i) => el.children[i].textContent = digit);\n                }\n\n                if (el.nextSibling !== null) {\n                    // html(el.nextSibling, sing ? pluralize.singular(data(el.nextSibling, 'label')) : pluralize.plural(data(el.nextSibling, 'label')));\n                    dom_html(el.nextSibling, attr_data(el.nextSibling, 'label'));\n                }\n\n            });\n\n        }\n\n    },\n\n    methods: {\n\n        start() {\n\n            this.stop();\n\n            if (this.date && this.units.length) {\n                this.$emit();\n                this.timer = setInterval(() => this.$emit(), 1000);\n            }\n\n            setTimeout(function () {\n                JDBuilderLivePreview.refresh();\n            }, 50);\n\n        },\n\n        stop() {\n            if (this.timer) {\n                clearInterval(this.timer);\n                this.timer = null;\n                this.check();\n            }\n        },\n\n        check() {\n            const timespan = getTimeSpan(this.date);\n\n            if (timespan.total <= 0) {\n                if (this.after == 'hide' || this.after == 'hide+message') {\n                    addClass(dom_$('.jdb-countdown-inner', this.$el), 'jdb-countdown-hide');\n                }\n\n                if (this.after == 'message' || this.after == 'hide+message') {\n                    if (dom_$('.jdb-countdown-message', this.$el) != null) {\n                        addClass(dom_$('.jdb-countdown-message', this.$el), 'jdb-countdown-show');\n                    }\n                }\n                if (this.redirect != '' && !this.redirectionDone) {\n                    this.redirectionDone = true;\n                    this.redirectTimer = setTimeout(() => {\n                        if (this.preview) {\n                            // alert(\"This page will redirect on`\" + decodeURI(this.redirect) + \"`\");\n                        } else {\n                            window.location.href = decodeURIComponent(this.redirect);\n                        }\n                    }, this.wait);\n                }\n            } else {\n                removeClass(dom_$('.jdb-countdown-inner', this.$el), 'jdb-countdown-hide');\n                if (dom_$('.jdb-countdown-message', this.$el) != null) {\n                    removeClass(dom_$('.jdb-countdown-message', this.$el), 'jdb-countdown-show');\n                }\n                if (this.redirect != '' && this.redirectTimer) {\n                    this.redirectionDone = false;\n                    clearInterval(this.redirectTimer);\n                    this.redirectTimer = null;\n                }\n            }\n        }\n\n    }\n\n});\n\nfunction getTimeSpan(date) {\n\n    const total = date - Date.now();\n\n    return {\n        total,\n        seconds: total / 1000 % 60,\n        minutes: total / 1000 / 60 % 60,\n        hours: total / 1000 / 60 / 60 % 24,\n        days: total / 1000 / 60 / 60 / 24\n    };\n}\n// CONCATENATED MODULE: ./src/core/jdbp/beforeafter.js\n\n/* harmony default export */ var beforeafter = ({\n\n    mixins: [mixin_class],\n\n    props: {\n        ukey: String,\n        moveSliderOnHover: Boolean,\n        orientation: String,\n        defaultOffset: Number,\n        overlay: String,\n    },\n\n    data: {\n        ukey: '',\n        moveSliderOnHover: false,\n        orientation: 'horizontal',\n        defaultOffset: 70,\n        overlay: 'hover',\n    },\n    computed: {\n\n        container() {\n            return $JDB(this.$el);\n        },\n        beforeImg() {\n            return this.container.children(\".jdb-beforeafter-before\");\n        },\n        afterImg() {\n            return this.container.children(\".jdb-beforeafter-after\");\n        },\n        slider() {\n            return this.container.children(\".jdb-beforeafter-handle\");\n        }\n\n    },\n    methods: {\n        beforeAfter() {\n            var sliderPct = (this.defaultOffset / 100);\n            var sliderOrientation = this.orientation;\n            var moveSliderOnHover = this.moveSliderOnHover;\n\n            var container = this.container;\n            var beforeImg = this.beforeImg;\n            var afterImg = this.afterImg;\n            var slider = this.slider;\n\n            var calcOffset = function (dimensionPct) {\n                var w = beforeImg.width();\n                var h = beforeImg.height();\n                return {\n                    w: w + \"px\",\n                    h: h + \"px\",\n                    cw: (dimensionPct * w) + \"px\",\n                    ch: (dimensionPct * h) + \"px\"\n                };\n            };\n\n            var adjustContainer = function (offset) {\n                if (sliderOrientation === 'vertical') {\n                    beforeImg.css(\"clip\", \"rect(0,\" + offset.w + \",\" + offset.ch + \",0)\");\n                    afterImg.css(\"clip\", \"rect(\" + offset.ch + \",\" + offset.w + \",\" + offset.h + \",0)\");\n                } else {\n                    beforeImg.css(\"clip\", \"rect(0,\" + offset.cw + \",\" + offset.h + \",0)\");\n                    afterImg.css(\"clip\", \"rect(0,\" + offset.w + \",\" + offset.h + \",\" + offset.cw + \")\");\n                }\n                container.css(\"height\", offset.h);\n            };\n\n            var adjustSlider = function (pct) {\n                var offset = calcOffset(pct);\n                slider.css((sliderOrientation === \"vertical\") ? \"top\" : \"left\", (sliderOrientation === \"vertical\") ? offset.ch : offset.cw);\n                slider.css((sliderOrientation === \"vertical\") ? \"left\" : \"top\", \"50%\");\n                adjustContainer(offset);\n            };\n\n            // Return the number specified or the min/max number if it outside the range given.\n            var minMaxNumber = function (num, min, max) {\n                return Math.max(min, Math.min(max, num));\n            };\n\n            // Calculate the slider percentage based on the position.\n            var getSliderPercentage = function (positionX, positionY) {\n                var sliderPercentage = (sliderOrientation === 'vertical') ?\n                    (positionY - offsetY) / imgHeight :\n                    (positionX - offsetX) / imgWidth;\n\n                return minMaxNumber(sliderPercentage, 0, 1);\n            };\n\n\n            $JDB(window).unbind(\"resize.jdbbeforeafter\").bind(\"resize.jdbbeforeafter\", function (e) {\n                adjustSlider(sliderPct);\n            });\n\n            var offsetX = 0;\n            var offsetY = 0;\n            var imgWidth = 0;\n            var imgHeight = 0;\n\n            var onMoveStart = function (e) {\n                if (((e.distX > e.distY && e.distX < -e.distY) || (e.distX < e.distY && e.distX > -e.distY)) && sliderOrientation !== 'vertical') {\n                    e.preventDefault();\n                } else if (((e.distX < e.distY && e.distX < -e.distY) || (e.distX > e.distY && e.distX > -e.distY)) && sliderOrientation === 'vertical') {\n                    e.preventDefault();\n                }\n                container.addClass(\"active\");\n                offsetX = container.offset().left;\n                offsetY = container.offset().top;\n                imgWidth = beforeImg.width();\n                imgHeight = beforeImg.height();\n            };\n\n            var onMove = function (e) {\n                if (container.hasClass(\"active\")) {\n                    sliderPct = getSliderPercentage(e.pageX, e.pageY);\n                    adjustSlider(sliderPct);\n                }\n            };\n            var onMoveEnd = function () {\n                container.removeClass(\"active\");\n            };\n\n            var moveTarget = slider;\n            moveTarget.unbind(\"movestart\").bind(\"movestart\", onMoveStart);\n            moveTarget.unbind(\"move\").bind(\"move\", onMove);\n            moveTarget.unbind(\"moveend\").bind(\"moveend\", onMoveEnd);\n\n            if (moveSliderOnHover) {\n                container.unbind(\"mouseenter\").bind(\"mouseenter\", onMoveStart);\n                container.unbind(\"mousemove\").bind(\"mousemove\", onMove);\n                container.unbind(\"mouseleave\").bind(\"mouseleave\", onMoveEnd);\n            } else {\n                container.unbind(\"mouseenter\");\n                container.unbind(\"mousemove\");\n                container.unbind(\"mouseleave\");\n            }\n\n            slider.unbind(\"touchmove\").bind(\"touchmove\", function (e) {\n                e.preventDefault();\n            });\n\n            beforeImg.unbind(\"mousedown\").bind(\"mousedown\", function (event) {\n                event.preventDefault();\n            });\n            afterImg.unbind(\"mousedown\").bind(\"mousedown\", function (event) {\n                event.preventDefault();\n            });\n\n            $JDB(window).trigger(\"resize.jdbbeforeafter\");\n            beforeImg.unbind('load').bind('load', function () {\n                $JDB(window).trigger(\"resize.jdbbeforeafter\");\n            });\n        },\n        init() {\n            this.beforeAfter();\n        }\n    },\n\n    connected() {\n        this.init();\n    }\n\n});\n// CONCATENATED MODULE: ./src/core/jdbp/jarticles.js\n\n/* harmony default export */ var jarticles = ({\n\n    mixins: [mixin_class],\n\n    props: {\n        id: String,\n        categories: String,\n        sub: Boolean,\n        count: Number,\n        featured: String,\n        ordering: String,\n        direction: String,\n        format: String,\n        viewmore: Number\n    },\n\n    data: {\n        id: '',\n        categories: '',\n        sub: false,\n        count: 10,\n        featured: 'show',\n        ordering: 'a.ordering',\n        direction: 'ASC',\n        format: 'd M, Y',\n        viewmore: 0\n    },\n    computed: {},\n    methods: {\n        init() {\n            var _id = this.id;\n            if (_id == '') {\n                throw 'Error with Joomla Articles element.';\n            }\n            if (_id == 0) {\n                return false;\n            }\n            var _container = $JDB(this.$el).parent('div');\n            var _categories = this.categories == '' ? [] : this.categories.split(',');\n            _container.addClass('loading');\n            var _count = this.count;\n            var _featured = this.featured;\n            var _ordering = this.ordering;\n            var _direction = this.direction;\n            var _viewmore = this.viewmore;\n            var _sub = this.sub;\n            var _format = this.format;\n\n            let promise = new Promise(function (resolve, reject) {\n                $JDB.ajax({\n                    url: window.jdPageBaseUrl + 'index.php?option=com_ajax&plugin=jdbuilder&group=system&method=element&format=json&task=joomla-articles.getArticles',\n                    method: 'get',\n                    data: {\n                        categories: _categories,\n                        count: _count,\n                        featured: _featured,\n                        ordering: _ordering,\n                        direction: _direction,\n                        viewmore: _viewmore,\n                        subcategories: _sub,\n                        dateFormat: _format,\n                    },\n                    success: function (response) {\n                        if (response.status != 'success') {\n                            throw 'Error(' + response.code + ') : ' + response.message;\n                        }\n                        resolve(response.data);\n                    }\n                });\n            });\n\n            promise.then(function (data) {\n                _JDBDATA.set(_id, data);\n                setTimeout(function () {\n                    _container.removeClass('loading');\n                    JDBuilderLivePreview.refresh();\n                }, 50);\n            });\n        }\n    },\n    connected() {\n        this.init();\n    }\n});\n// CONCATENATED MODULE: ./src/core/jdbp/jarticle.js\n\n/* harmony default export */ var jarticle = ({\n\n    mixins: [mixin_class],\n\n    props: {\n        eid: String,\n        id: Number,\n        format: String\n    },\n\n    data: {\n        eid: '',\n        id: 0,\n        format: 'd M, Y'\n    },\n    computed: {},\n    methods: {\n        init() {\n            var _id = this.eid;\n            var _articleId = this.id;\n            if (_id == '') {\n                throw 'Error with Joomla Article element.';\n            }\n            var _container = $JDB(this.$el).parent('div');\n            _container.addClass('loading');\n            var _format = this.format;\n\n            let promise = new Promise(function (resolve, reject) {\n                $JDB.ajax({\n                    url: window.jdPageBaseUrl + 'index.php?option=com_ajax&plugin=jdbuilder&group=system&method=element&format=json&task=jarticle.getArticle',\n                    method: 'get',\n                    data: {\n                        id: _articleId,\n                        dateFormat: _format\n                    },\n                    success: function (response) {\n                        if (response.status != 'success') {\n                            throw 'Error(' + response.code + ') : ' + response.message;\n                        }\n                        resolve(response.data);\n                    }\n                });\n            });\n\n            promise.then(function (data) {\n                _JDBDATA.set(_id, data);\n                setTimeout(function () {\n                    _container.removeClass('loading');\n                    JDBuilderLivePreview.refresh();\n                }, 50);\n            });\n        }\n    },\n    connected() {\n        this.init();\n    }\n});\n// CONCATENATED MODULE: ./src/core/jdbp/fileinput.js\n/* harmony default export */ var fileinput = ({\n    props: {\n        label: String\n    },\n\n    methods: {\n        init() {\n            this.label = $JDB(this.$el).siblings('label').text();\n        },\n        change() {\n            var _val = $JDB(this.$el).val().split(\"\\\\\").pop();\n            if (_val != null && _val != '') {\n                $JDB(this.$el).siblings('label').text(_val);\n            } else {\n                $JDB(this.$el).siblings('label').text(this.label);\n            }\n        }\n    },\n\n    connected() {\n        this.init();\n    },\n\n    events: [\n\n        {\n            name: 'change',\n            handler(e) {\n                e.preventDefault();\n                this.change();\n            }\n        }\n    ],\n\n});\n// CONCATENATED MODULE: ./src/core/jdbp/form.js\n\n\n/* harmony default export */ var jdbp_form = ({\n    props: {\n        url: String\n    },\n\n    data: {\n        url: '',\n        beforeSend: lang[\"noop\"],\n        onSuccess: lang[\"noop\"],\n        onError: lang[\"noop\"]\n    },\n\n    methods: {\n        submit() {\n            var _this = this;\n            var element = $JDB(this.$el);\n\n            var form = element[0];\n            var data = new FormData(form);\n\n            var event = new CustomEvent('onAjaxCallInPreview');\n            parent.dispatchEvent(event);\n\n            $JDB.ajax({\n                url: _this.url,\n                enctype: 'multipart/form-data',\n                method: 'POST',\n                processData: false,\n                contentType: false,\n                cache: false,\n                data: data,\n                beforeSend: function (jqXHR) {\n                    _this.beforeSend(jqXHR);\n                },\n                success: function (response) {\n                    _this.onSuccess(response);\n                },\n                error: function (e) {\n                    _this.onError(e);\n                }\n            });\n        }\n    },\n\n    connected() {}\n});\n// CONCATENATED MODULE: ./src/core/jdbp/preview.js\n\n\n/* harmony default export */ var preview = ({\n    methods: {\n        before() {\n            try {\n                beforePreviewCompile();\n            } catch (e) {}\n        },\n        after() {\n            try {\n                afterPreviewCompile();\n            } catch (e) {}\n        }\n    },\n\n    connected() {\n        var event = attr_data(this.$el, 'event');\n        if (event === 'before') {\n            this.before();\n        } else {\n            this.after();\n        }\n    },\n});\n// CONCATENATED MODULE: ./src/core/jdbp/datepicker.js\n\n/* harmony default export */ var datepicker = ({\n\n    mixins: [mixin_class],\n\n    props: {\n        min: String,\n        max: String,\n        format: String\n    },\n\n    data: {\n        min: '',\n        max: '',\n        format: 'MM-DD-YYYY',\n        input: null\n    },\n\n    methods: {\n        getformat() {\n            return this.format == '' ? 'MM-DD-YYYY' : this.format;\n        },\n        init() {\n            var _this = this;\n            if (this.input === null) {\n                this.input = new Pikaday({\n                    field: this.$el,\n                    toString: function(date, f){\n                        var format = _this.getformat();\n                        return moment(date).format(format);\n                    }\n                });\n            }\n\n            if (this.min != '') {\n                this.input.setMinDate(moment(this.min).toDate());\n            }\n            \n            if (this.max != '') {\n                this.input.setMaxDate(moment(this.max).toDate());\n            }\n\n            if(moment(this.min).toDate() > new Date()){\n                this.input.setDate(moment(this.min).toDate());\n            }else{\n                this.input.setDate(new Date());\n            }\n\n\n            /* var options = {};\n            if ($JDB(this).data('format') != undefined && $JDB(this).data('format') != '') {\n                options.format = $JDB(this).data('format');\n            }\n            var pikaday = $JDB(this).pikaday(options);\n            if ($JDB(this).data('min') != undefined && $JDB(this).data('min') != '') {\n                pikaday.setMinDate(moment($JDB(this).data('min')).toDate());\n            }\n            if ($JDB(this).data('max') != undefined && $JDB(this).data('max') != '') {\n                pikaday.setMaxDate(moment($JDB(this).data('max')).toDate());\n            } */\n        }\n    },\n\n    connected() {\n        this.init();\n    }\n\n});\n// CONCATENATED MODULE: ./src/core/jdbp/phoneinput.js\n\n\n/* harmony default export */ var phoneinput = ({\n    props: {\n        format: String,\n        country: Boolean,\n    },\n\n    data: {\n        format: '',\n        country: false\n    },\n\n    methods: {\n        padding() {\n            const $el = this.$el;\n            if (this.country) {\n                const _id = $JDB($el).attr('id');\n                const _width = $JDB('#' + _id + '__countycodeContainer').width();\n                $JDB($el).css('padding-left', _width);\n            } else {\n                $JDB($el).css('padding-left', '');\n            }\n        },\n        initValue() {\n            const $el = this.$el;\n            const _id = $JDB($el).attr('id');\n            const _code = $('#' + _id + '__countycode').val();\n            const _phone = $('#' + _id).val();\n            let _value = '';\n            if (this.country) {\n                _value = '(+' + _code + ') ' + _phone;\n            } else {\n                _value = _phone;\n            }\n            $('#' + _id + '__value').val(_value);\n        },\n        init() {\n            const $el = this.$el;\n            try {\n                const _this = this;\n                const _id = $JDB($el).attr('id');\n                const input = IMask($el, {\n                    mask: this.format\n                }).on('accept', function () {\n                    if (hasClass($el, 'jdb-phoneinput-complete')) {\n                        removeClass($el, 'jdb-phoneinput-complete')\n                    }\n                    _this.initValue();\n                }).on('complete', function () {\n                    addClass($el, 'jdb-phoneinput-complete');\n                    _this.initValue();\n                });\n                if (_this.country) {\n                    const selector = new Selectr('#' + _id + '__countycode', {\n                        renderOption: function (option) {\n                            return '<span class=\"jdb-country-option-item\"><span class=\"jdb-flag jdb-flag-' + option.dataset.countrycode.toLowerCase() + '\"></span><span>' + option.textContent + '</span></span>';\n                        },\n                        renderSelection: function (option) {\n                            return '<span class=\"jdb-country-option-selected\"><span class=\"jdb-flag jdb-flag-' + option.dataset.countrycode.toLowerCase() + '\"></span><span>(+' + option.value + ')</span></span>';\n                        }\n                    });\n                    selector.on('selectr.init', function () {\n                        _this.padding();\n                    });\n                    selector.on('selectr.select', function (option) {\n                        _this.padding();\n                        _this.initValue();\n                    });\n                }\n                _this.initValue();\n            } catch (e) {}\n        }\n    },\n\n    connected() {\n        this.init();\n    }\n\n});\n// CONCATENATED MODULE: ./src/components/internal/lightbox-animations.js\n\n\n\n/* harmony default export */ var lightbox_animations = (Object(lang[\"assign\"])({}, slideshow_animations, {\n\n    fade: {\n\n        show() {\n            return [\n                {opacity: 0},\n                {opacity: 1}\n            ];\n        },\n\n        percent(current) {\n            return 1 - style_css(current, 'opacity');\n        },\n\n        translate(percent) {\n            return [\n                {opacity: 1 - percent},\n                {opacity: percent}\n            ];\n        }\n\n    },\n\n    scale: {\n\n        show() {\n            return [\n                {opacity: 0, transform: scale3d(1 - .2)},\n                {opacity: 1, transform: scale3d(1)}\n            ];\n        },\n\n        percent(current) {\n            return 1 - style_css(current, 'opacity');\n        },\n\n        translate(percent) {\n            return [\n                {opacity: 1 - percent, transform: scale3d(1 - .2 * percent)},\n                {opacity: percent, transform: scale3d(1 - .2 + .2 * percent)}\n            ];\n        }\n\n    }\n\n}));\n\n// CONCATENATED MODULE: ./src/mixin/container.js\n\n\n/* harmony default export */ var mixin_container = ({\n\n    props: {\n        container: Boolean\n    },\n\n    data: {\n        container: true\n    },\n\n    computed: {\n\n        container({container}) {\n            return container === true && this.$container || container && dom_$(container);\n        }\n\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/mixin/modal.js\n\n\n\n\n\nlet modal_active;\n\n/* harmony default export */ var modal = ({\n\n    mixins: [mixin_class, mixin_container, togglable],\n\n    props: {\n        selPanel: String,\n        selClose: String,\n        escClose: Boolean,\n        bgClose: Boolean,\n        stack: Boolean\n    },\n\n    data: {\n        cls: 'uk-open',\n        escClose: true,\n        bgClose: true,\n        overlay: true,\n        stack: false\n    },\n\n    computed: {\n\n        panel({selPanel}, $el) {\n            return dom_$(selPanel, $el);\n        },\n\n        transitionElement() {\n            return this.panel;\n        },\n\n        bgClose({bgClose}) {\n            return bgClose && this.panel;\n        }\n\n    },\n\n    beforeDisconnect() {\n        if (this.isToggled()) {\n            this.toggleNow(this.$el, false);\n        }\n    },\n\n    events: [\n\n        {\n\n            name: 'click',\n\n            delegate() {\n                return this.selClose;\n            },\n\n            handler(e) {\n                e.preventDefault();\n                this.hide();\n            }\n\n        },\n\n        {\n\n            name: 'toggle',\n\n            self: true,\n\n            handler(e) {\n\n                if (e.defaultPrevented) {\n                    return;\n                }\n\n                e.preventDefault();\n                this.toggle();\n            }\n\n        },\n\n        {\n            name: 'beforeshow',\n\n            self: true,\n\n            handler(e) {\n\n                const prev = modal_active && modal_active !== this && modal_active;\n\n                modal_active = this;\n\n                if (prev) {\n                    if (this.stack) {\n                        this.prev = prev;\n                    } else {\n\n                        modal_active = prev;\n\n                        if (prev.isToggled()) {\n                            prev.hide().then(this.show);\n                        } else {\n                            once(prev.$el, 'beforeshow hidden', this.show, false, ({target, type}) => type === 'hidden' && target === prev.$el);\n                        }\n                        e.preventDefault();\n\n                    }\n\n                    return;\n                }\n\n                registerEvents();\n\n            }\n\n        },\n\n        {\n\n            name: 'show',\n\n            self: true,\n\n            handler() {\n\n                if (!hasClass(document.documentElement, this.clsPage)) {\n                    this.scrollbarWidth = dimensions_width(window) - dimensions_width(document);\n                    style_css(document.body, 'overflowY', this.scrollbarWidth && this.overlay ? 'scroll' : '');\n                }\n\n                addClass(document.documentElement, this.clsPage);\n\n            }\n\n        },\n\n        {\n\n            name: 'hide',\n\n            self: true,\n\n            handler() {\n                if (!modal_active || modal_active === this && !this.prev) {\n                    deregisterEvents();\n                }\n            }\n\n        },\n\n        {\n\n            name: 'hidden',\n\n            self: true,\n\n            handler() {\n\n                let found, {prev} = this;\n\n                modal_active = modal_active && modal_active !== this && modal_active || prev;\n\n                if (!modal_active) {\n\n                    style_css(document.body, 'overflowY', '');\n\n                } else {\n                    while (prev) {\n\n                        if (prev.clsPage === this.clsPage) {\n                            found = true;\n                            break;\n                        }\n\n                        prev = prev.prev;\n\n                    }\n\n                }\n\n                if (!found) {\n                    removeClass(document.documentElement, this.clsPage);\n                }\n\n            }\n\n        }\n\n    ],\n\n    methods: {\n\n        toggle() {\n            return this.isToggled() ? this.hide() : this.show();\n        },\n\n        show() {\n\n            if (this.isToggled()) {\n                return util_promise[\"Promise\"].resolve();\n            }\n\n            if (this.container && this.$el.parentNode !== this.container) {\n                append(this.container, this.$el);\n                return new util_promise[\"Promise\"](resolve =>\n                    requestAnimationFrame(() =>\n                        this.show().then(resolve)\n                    )\n                );\n            }\n\n            return this.toggleElement(this.$el, true, modal_animate(this));\n        },\n\n        hide() {\n            return this.isToggled()\n                ? this.toggleElement(this.$el, false, modal_animate(this))\n                : util_promise[\"Promise\"].resolve();\n        },\n\n        getActive() {\n            return modal_active;\n        }\n\n    }\n\n});\n\nlet modal_events;\n\nfunction registerEvents() {\n\n    if (modal_events) {\n        return;\n    }\n\n    modal_events = [\n        on(document, pointerUp, ({target, defaultPrevented}) => {\n            if (modal_active && modal_active.bgClose && !defaultPrevented && (!modal_active.overlay || within(target, modal_active.$el)) && !within(target, modal_active.panel)) {\n                modal_active.hide();\n            }\n        }),\n        on(document, 'keydown', e => {\n            if (e.keyCode === 27 && modal_active && modal_active.escClose) {\n                e.preventDefault();\n                modal_active.hide();\n            }\n        })\n    ];\n}\n\nfunction deregisterEvents() {\n    modal_events && modal_events.forEach(unbind => unbind());\n    modal_events = null;\n}\n\nfunction modal_animate({transitionElement, _toggle}) {\n    return (el, show) =>\n        new util_promise[\"Promise\"]((resolve, reject) =>\n            once(el, 'show hide', () => {\n                el._reject && el._reject();\n                el._reject = reject;\n\n                _toggle(el, show);\n\n                if (Object(lang[\"toMs\"])(style_css(transitionElement, 'transitionDuration'))) {\n                    once(transitionElement, 'transitionend', resolve, false, e => e.target === transitionElement);\n                } else {\n                    resolve();\n                }\n            })\n        );\n}\n\n// CONCATENATED MODULE: ./src/components/lightbox-panel.js\n\n\n\n\n\n\n\n/* harmony default export */ var lightbox_panel = ({\n\n    mixins: [mixin_container, modal, togglable, slideshow],\n\n    functional: true,\n\n    props: {\n        delayControls: Number,\n        preload: Number,\n        videoAutoplay: Boolean,\n        template: String\n    },\n\n    data: () => ({\n        preload: 1,\n        videoAutoplay: false,\n        delayControls: 3000,\n        items: [],\n        cls: 'jdb-open',\n        clsPage: 'jdb-lightbox-page',\n        selList: '.jdb-lightbox-items',\n        attrItem: 'jdb-lightbox-item',\n        selClose: '.jdb-close-large',\n        pauseOnHover: false,\n        velocity: 2,\n        Animations: lightbox_animations,\n        template: `<div class=\"jdb-lightbox jdb-overflow-hidden\">\n                        <ul class=\"jdb-lightbox-items\"></ul>\n                        <div class=\"jdb-lightbox-toolbar jdb-position-top jdb-text-right jdb-transition-slide-top jdb-transition-opaque\">\n                            <button class=\"jdb-lightbox-toolbar-icon jdb-close-large\" type=\"button\" jdb-close></button>\n                         </div>\n                        <a class=\"jdb-lightbox-button jdb-position-center-left jdb-position-medium jdb-transition-fade\" href=\"#\" jdb-slidenav-previous jdb-lightbox-item=\"previous\"></a>\n                        <a class=\"jdb-lightbox-button jdb-position-center-right jdb-position-medium jdb-transition-fade\" href=\"#\" jdb-slidenav-next jdb-lightbox-item=\"next\"></a>\n                        <div class=\"jdb-lightbox-toolbar jdb-lightbox-caption jdb-position-bottom jdb-text-center jdb-transition-slide-bottom jdb-transition-opaque\"></div>\n                    </div>`\n    }),\n\n    created() {\n\n        this.$mount(append(this.container, this.template));\n\n        this.caption = dom_$('.jdb-lightbox-caption', this.$el);\n\n        this.items.forEach(() => append(this.list, '<li></li>'));\n\n    },\n\n    events: [\n\n        {\n\n            name: `${pointerMove} ${pointerDown} keydown`,\n\n            handler: 'showControls'\n\n        },\n\n        {\n\n            name: 'click',\n\n            self: true,\n\n            delegate() {\n                return this.selSlides;\n            },\n\n            handler(e) {\n\n                if (e.defaultPrevented) {\n                    return;\n                }\n\n                this.hide();\n            }\n\n        },\n\n        {\n\n            name: 'shown',\n\n            self: true,\n\n            handler() {\n                this.showControls();\n            }\n\n        },\n\n        {\n\n            name: 'hide',\n\n            self: true,\n\n            handler() {\n\n                this.hideControls();\n\n                removeClass(this.slides, this.clsActive);\n                Transition.stop(this.slides);\n\n            }\n        },\n\n        {\n\n            name: 'hidden',\n\n            self: true,\n\n            handler() {\n                this.$destroy(true);\n            }\n\n        },\n\n        {\n\n            name: 'keyup',\n\n            el: document,\n\n            handler(e) {\n\n                if (!this.isToggled(this.$el)) {\n                    return;\n                }\n\n                switch (e.keyCode) {\n                    case 37:\n                        this.show('previous');\n                        break;\n                    case 39:\n                        this.show('next');\n                        break;\n                }\n            }\n        },\n\n        {\n\n            name: 'beforeitemshow',\n\n            handler(e) {\n\n                if (this.isToggled()) {\n                    return;\n                }\n\n                this.draggable = false;\n\n                e.preventDefault();\n\n                this.toggleNow(this.$el, true);\n\n                this.animation = lightbox_animations['scale'];\n                removeClass(e.target, this.clsActive);\n                this.stack.splice(1, 0, this.index);\n\n            }\n\n        },\n\n        {\n\n            name: 'itemshow',\n\n            handler({target}) {\n\n                const i = dom_index(target);\n                const {caption} = this.getItem(i);\n\n                style_css(this.caption, 'display', caption ? '' : 'none');\n                dom_html(this.caption, caption);\n\n                for (let j = 0; j <= this.preload; j++) {\n                    this.loadItem(this.getIndex(i + j));\n                    this.loadItem(this.getIndex(i - j));\n                }\n\n            }\n\n        },\n\n        {\n\n            name: 'itemshown',\n\n            handler() {\n                this.draggable = this.$props.draggable;\n            }\n\n        },\n\n        {\n\n            name: 'itemload',\n\n            handler(_, item) {\n\n                const {source, type, alt} = item;\n\n                this.setItem(item, '<span jdb-spinner></span>');\n\n                if (!source) {\n                    return;\n                }\n\n                let matches;\n\n                // Image\n                if (type === 'image' || source.match(/\\.(jp(e)?g|png|gif|svg|webp)($|\\?)/i)) {\n\n                    getImage(source).then(\n                        img => this.setItem(item, `<img width=\"${img.width}\" height=\"${img.height}\" src=\"${source}\" alt=\"${alt ? alt : ''}\">`),\n                        () => this.setError(item)\n                    );\n\n                    // Video\n                } else if (type === 'video' || source.match(/\\.(mp4|webm|ogv)($|\\?)/i)) {\n\n                    const video = dom_$(`<video controls playsinline${item.poster ? ` poster=\"${item.poster}\"` : ''} jdb-video=\"${this.videoAutoplay}\"></video>`);\n                    attr_attr(video, 'src', source);\n\n                    once(video, 'error loadedmetadata', type => {\n                        if (type === 'error') {\n                            this.setError(item);\n                        } else {\n                            attr_attr(video, {width: video.videoWidth, height: video.videoHeight});\n                            this.setItem(item, video);\n                        }\n                    });\n\n                    // Iframe\n                } else if (type === 'iframe' || source.match(/\\.(html|php)($|\\?)/i)) {\n\n                    this.setItem(item, `<iframe class=\"jdb-lightbox-iframe\" src=\"${source}\" frameborder=\"0\" allowfullscreen></iframe>`);\n\n                    // YouTube\n                } else if ((matches = source.match(/\\/\\/.*?youtube(-nocookie)?\\.[a-z]+\\/watch\\?v=([^&\\s]+)/) || source.match(/()youtu\\.be\\/(.*)/))) {\n\n                    const [, , id] = matches;\n                    const setIframe = (width = 640, height = 450) => this.setItem(item, getIframe(`https://www.youtube${matches[1] || ''}.com/embed/${id}`, width, height, this.videoAutoplay));\n\n                    /* getImage(`https://img.youtube.com/vi/${id}/maxresdefault.jpg`).then(\n                        ({width, height}) => {\n                            if (width === 120 && height === 90) {\n                                getImage(`https://img.youtube.com/vi/${id}/0.jpg`).then(\n                                    ({width, height}) => setIframe(width, height),\n                                    setIframe\n                                );\n                            } else {\n                                setIframe(width, height);\n                            }\n                        },\n                        setIframe\n                    ); */\n\n                    // Vimeo\n                } else if ((matches = source.match(/(\\/\\/.*?)vimeo\\.[a-z]+\\/([0-9]+).*?/))) {\n\n                    /* ajax(`https://vimeo.com/api/oembed.json?maxwidth=1920&url=${encodeURI(source)}`, {responseType: 'json', withCredentials: false})\n                        .then(\n                            ({response: {height, width}}) => this.setItem(item, getIframe(`https://player.vimeo.com/video/${matches[2]}`, width, height, this.videoAutoplay)),\n                            () => this.setError(item)\n                        ); */\n\n                }\n\n            }\n\n        }\n\n    ],\n\n    methods: {\n\n        loadItem(index = this.index) {\n\n            const item = this.getItem(index);\n\n            if (item.content) {\n                return;\n            }\n\n            trigger(this.$el, 'itemload', [item]);\n        },\n\n        getItem(index = this.index) {\n            return this.items[index] || {};\n        },\n\n        setItem(item, content) {\n            Object(lang[\"assign\"])(item, {content});\n            const el = dom_html(this.slides[this.items.indexOf(item)], content);\n            trigger(this.$el, 'itemloaded', [this, el]);\n            this.$update(el);\n        },\n\n        setError(item) {\n            this.setItem(item, '<span jdb-icon=\"icon: bolt; ratio: 2\"></span>');\n        },\n\n        showControls() {\n\n            clearTimeout(this.controlsTimer);\n            this.controlsTimer = setTimeout(this.hideControls, this.delayControls);\n\n            addClass(this.$el, 'jdb-active', 'jdb-transition-active');\n\n        },\n\n        hideControls() {\n            removeClass(this.$el, 'jdb-active', 'jdb-transition-active');\n        }\n\n    }\n\n});\n\nfunction getIframe(src, width, height, autoplay) {\n    return `<iframe src=\"${src}\" width=\"${width}\" height=\"${height}\" style=\"max-width: 100%; box-sizing: border-box;\" frameborder=\"0\" allowfullscreen jdb-video=\"autoplay: ${autoplay}\" jdb-responsive></iframe>`;\n}\n\n// CONCATENATED MODULE: ./src/components/lightbox.js\n\n\n\n/* harmony default export */ var lightbox = ({\n\n    install,\n\n    props: {toggle: String},\n\n    data: {toggle: 'a'},\n\n    computed: {\n\n        toggles: {\n\n            get({toggle}, $el) {\n                return $$(toggle, $el);\n            },\n\n            watch() {\n                this.hide();\n            }\n\n        },\n\n        items() {\n            return Object(lang[\"uniqueBy\"])(this.toggles.map(toItem), 'source');\n        }\n\n    },\n\n    disconnected() {\n        this.hide();\n    },\n\n    events: [\n\n        {\n\n            name: 'click',\n\n            delegate() {\n                return `${this.toggle}:not(.jdb-disabled)`;\n            },\n\n            handler(e) {\n                e.preventDefault();\n                const src = attr_data(e.current, 'href');\n                this.show(Object(lang[\"findIndex\"])(this.items, ({source}) => source === src));\n            }\n\n        }\n\n    ],\n\n    methods: {\n\n        show(index) {\n\n            this.panel = this.panel || this.$create('lightboxPanel', Object(lang[\"assign\"])({}, this.$props, {items: this.items}));\n\n            on(this.panel.$el, 'hidden', () => this.panel = false);\n\n            return this.panel.show(index);\n\n        },\n\n        hide() {\n\n            return this.panel && this.panel.hide();\n\n        }\n\n    }\n\n});\n\nfunction install(UIkit, Lightbox) {\n\n    if (!UIkit.lightboxPanel) {\n        UIkit.component('lightboxPanel', lightbox_panel);\n    }\n\n    Object(lang[\"assign\"])(\n        Lightbox.props,\n        UIkit.component('lightboxPanel').options.props\n    );\n\n}\n\nfunction toItem(el) {\n    return ['href', 'caption', 'type', 'poster', 'alt'].reduce((obj, attr) => {\n        obj[attr === 'href' ? 'source' : attr] = attr_data(el, attr);\n        return obj;\n    }, {});\n}\n\n// CONCATENATED MODULE: ./src/core/index.js\n//import Accordion from './accordion';\n//import Alert from './alert';\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//import Drop from './drop';\n//import Dropdown from './dropdown';\n//import FormCustom from './form-custom';\n//import Gif from './gif';\n//import Grid from './grid';\n//import HeightMatch from './height-match';\n//import HeightViewport from './height-viewport';\n//import Icon, {IconComponent, Slidenav, Search, Close, Spinner} from './icon';\n//import Img from './img';\n//import Leader from './leader';\n//import Margin from './margin';\n//import Modal from './modal';\n//import Nav from './nav';\n//import Navbar from './navbar';\n//import Offcanvas from './offcanvas';\n//import OverflowAuto from './overflow-auto';\n//import Responsive from './responsive';\n//import Scroll from './scroll';\n//import Scrollspy from './scrollspy';\n//import ScrollspyNav from './scrollspy-nav';\n//import Sticky from './sticky';\n//import Svg from './svg';\n//import Switcher from './switcher';\n//import Tab from './tab';\n//import Toggle from './toggle';\n//import Video from './video';\n\n/* harmony default export */ var src_core = (function (UIkit) {\n\n   // core components\n   //UIkit.component('accordion', Accordion);\n   UIkit.component('loader', loader);\n   UIkit.component('section', section);\n   UIkit.component('row', row);\n   UIkit.component('alert', jdbp_alert);\n   UIkit.component('sliderContent', cover);\n   UIkit.component('accordion', accordion);\n   UIkit.component('tab', tab);\n   UIkit.component('slider', jdbp_slider);\n   UIkit.component('slideshow', jdbp_slideshow);\n   UIkit.component('animation', jdbp_animation);\n   UIkit.component('animatedheading', animatedheading);\n   UIkit.component('masonryGallery', masonrygallery);\n   UIkit.component('justifyGallery', justifygallery);\n   UIkit.component('gridGallery', gridgallery);\n   UIkit.component('particles', particles);\n   UIkit.component('gmap', gmap);\n   UIkit.component('video', jdbp_video);\n   UIkit.component('videoBackground', videoBackground);\n   UIkit.component('ytsubscribe', ytsubscribe);\n   UIkit.component('progressbar', progressbar);\n   UIkit.component('counter', counter);\n   UIkit.component('countdown', countdown);\n   UIkit.component('beforeAfter', beforeafter);\n   UIkit.component('jarticles', jarticles);\n   UIkit.component('jarticle', jarticle);\n   UIkit.component('fileinput', fileinput);\n   UIkit.component('form', jdbp_form);\n   UIkit.component('datepicker', datepicker);\n   UIkit.component('phoneinput', phoneinput);\n   UIkit.component('preview', preview);\n   // UIkit.component('lightbox', Lightbox);\n   // UIkit.component('lightboxpanel', LightboxPanel);\n   //UIkit.component('drop', Drop);\n   //UIkit.component('dropdown', Dropdown);\n   //UIkit.component('formCustom', FormCustom);\n   //UIkit.component('gif', Gif);\n   //UIkit.component('grid', Grid);\n   //UIkit.component('heightMatch', HeightMatch);\n   //UIkit.component('heightViewport', HeightViewport);\n   //UIkit.component('icon', Icon);\n   //UIkit.component('img', Img);\n   //UIkit.component('leader', Leader);\n   //UIkit.component('margin', Margin);\n   //UIkit.component('modal', Modal);\n   //UIkit.component('nav', Nav);\n   //UIkit.component('navbar', Navbar);\n   //UIkit.component('offcanvas', Offcanvas);\n   //UIkit.component('overflowAuto', OverflowAuto);\n   //UIkit.component('responsive', Responsive);\n   //UIkit.component('scroll', Scroll);\n   //UIkit.component('scrollspy', Scrollspy);\n   //UIkit.component('scrollspyNav', ScrollspyNav);\n   //UIkit.component('sticky', Sticky);\n   //UIkit.component('svg', Svg);\n   //UIkit.component('switcher', Switcher);\n   //UIkit.component('tab', Tab);\n   //UIkit.component('toggle', Toggle);\n   //UIkit.component('video', Video);\n\n   // Icon components\n   //UIkit.component('close', Close);\n   //UIkit.component('marker', IconComponent);\n   //UIkit.component('navbarToggleIcon', IconComponent);\n   //UIkit.component('overlayIcon', IconComponent);\n   //UIkit.component('paginationNext', IconComponent);\n   //UIkit.component('paginationPrevious', IconComponent);\n   //UIkit.component('searchIcon', Search);\n   //UIkit.component('slidenavNext', Slidenav);\n   //UIkit.component('slidenavPrevious', Slidenav);\n   //UIkit.component('spinner', Spinner);\n   //UIkit.component('totop', IconComponent);\n\n   // core functionality\n   UIkit.use(core);\n\n});\n// CONCATENATED MODULE: ./src/uikit-core.js\n\n\n\n\napi.version = '1.0.0';\n\nsrc_core(api);\n\nif (false) {}\n\n/* harmony default export */ var uikit_core = (api);\n\n// CONCATENATED MODULE: ./src/uikit.js\n\n\n\nif (true) {\n    boot(uikit_core);\n}\n\nuikit_core.PARTICLES = [];\n\n/* harmony default export */ var uikit = __webpack_exports__[\"default\"] = (uikit_core);\n\n//# sourceURL=webpack://UIkit/./src/uikit.js_+_74_modules?");

/***/ }),

/***/ "./src/util/lang.js":
/*!**************************!*\
  !*** ./src/util/lang.js ***!
  \**************************/
/*! exports provided: bind, hasOwn, hyphenate, camelize, ucfirst, startsWith, endsWith, includes, findIndex, isArray, isFunction, isObject, isPlainObject, isWindow, isDocument, isJQuery, isNode, isNodeCollection, isBoolean, isString, isNumber, isNumeric, isEmpty, isUndefined, toBoolean, toNumber, toFloat, toNode, toNodes, toList, toMs, isEqual, swap, assign, each, sortBy, uniqueBy, clamp, noop, intersectRect, pointInRect, Dimensions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"bind\", function() { return bind; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hasOwn\", function() { return hasOwn; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hyphenate\", function() { return hyphenate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"camelize\", function() { return camelize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ucfirst\", function() { return ucfirst; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"startsWith\", function() { return startsWith; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"endsWith\", function() { return endsWith; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"includes\", function() { return includes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findIndex\", function() { return findIndex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isArray\", function() { return isArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isFunction\", function() { return isFunction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isObject\", function() { return isObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isPlainObject\", function() { return isPlainObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isWindow\", function() { return isWindow; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isDocument\", function() { return isDocument; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isJQuery\", function() { return isJQuery; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNode\", function() { return isNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNodeCollection\", function() { return isNodeCollection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isBoolean\", function() { return isBoolean; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isString\", function() { return isString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNumber\", function() { return isNumber; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNumeric\", function() { return isNumeric; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isEmpty\", function() { return isEmpty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isUndefined\", function() { return isUndefined; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toBoolean\", function() { return toBoolean; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toNumber\", function() { return toNumber; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toFloat\", function() { return toFloat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toNode\", function() { return toNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toNodes\", function() { return toNodes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toList\", function() { return toList; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toMs\", function() { return toMs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isEqual\", function() { return isEqual; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"swap\", function() { return swap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"assign\", function() { return assign; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"each\", function() { return each; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sortBy\", function() { return sortBy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"uniqueBy\", function() { return uniqueBy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clamp\", function() { return clamp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"noop\", function() { return noop; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"intersectRect\", function() { return intersectRect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pointInRect\", function() { return pointInRect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Dimensions\", function() { return Dimensions; });\nfunction bind(fn, context) {\n    return function (a) {\n        const l = arguments.length;\n        return l ? l > 1 ? fn.apply(context, arguments) : fn.call(context, a) : fn.call(context);\n    };\n}\n\nconst objPrototype = Object.prototype;\nconst {hasOwnProperty} = objPrototype;\n\nfunction hasOwn(obj, key) {\n    return hasOwnProperty.call(obj, key);\n}\n\nconst hyphenateCache = {};\nconst hyphenateRe = /([a-z\\d])([A-Z])/g;\n\nfunction hyphenate(str) {\n\n    if (!(str in hyphenateCache)) {\n        hyphenateCache[str] = str\n            .replace(hyphenateRe, '$1-$2')\n            .toLowerCase();\n    }\n\n    return hyphenateCache[str];\n}\n\nconst camelizeRe = /-(\\w)/g;\n\nfunction camelize(str) {\n    return str.replace(camelizeRe, toUpper);\n}\n\nfunction toUpper(_, c) {\n    return c ? c.toUpperCase() : '';\n}\n\nfunction ucfirst(str) {\n    return str.length ? toUpper(null, str.charAt(0)) + str.slice(1) : '';\n}\n\nconst strPrototype = String.prototype;\nconst startsWithFn = strPrototype.startsWith || function (search) { return this.lastIndexOf(search, 0) === 0; };\n\nfunction startsWith(str, search) {\n    return startsWithFn.call(str, search);\n}\n\nconst endsWithFn = strPrototype.endsWith || function (search) { return this.substr(-search.length) === search; };\n\nfunction endsWith(str, search) {\n    return endsWithFn.call(str, search);\n}\n\nconst arrPrototype = Array.prototype;\n\nconst includesFn = function (search, i) { return ~this.indexOf(search, i); };\nconst includesStr = strPrototype.includes || includesFn;\nconst includesArray = arrPrototype.includes || includesFn;\n\nfunction includes(obj, search) {\n    return obj && (isString(obj) ? includesStr : includesArray).call(obj, search);\n}\n\nconst findIndexFn = arrPrototype.findIndex || function (predicate) {\n    for (let i = 0; i < this.length; i++) {\n        if (predicate.call(arguments[1], this[i], i, this)) {\n            return i;\n        }\n    }\n    return -1;\n};\n\nfunction findIndex(array, predicate) {\n    return findIndexFn.call(array, predicate);\n}\n\nconst {isArray} = Array;\n\nfunction isFunction(obj) {\n    return typeof obj === 'function';\n}\n\nfunction isObject(obj) {\n    return obj !== null && typeof obj === 'object';\n}\n\nfunction isPlainObject(obj) {\n    return isObject(obj) && Object.getPrototypeOf(obj) === objPrototype;\n}\n\nfunction isWindow(obj) {\n    return isObject(obj) && obj === obj.window;\n}\n\nfunction isDocument(obj) {\n    return isObject(obj) && obj.nodeType === 9;\n}\n\nfunction isJQuery(obj) {\n    return isObject(obj) && !!obj.jquery;\n}\n\nfunction isNode(obj) {\n    return obj instanceof Node || isObject(obj) && obj.nodeType >= 1;\n}\n\nconst {toString} = objPrototype;\nfunction isNodeCollection(obj) {\n    return toString.call(obj).match(/^\\[object (NodeList|HTMLCollection)\\]$/);\n}\n\nfunction isBoolean(value) {\n    return typeof value === 'boolean';\n}\n\nfunction isString(value) {\n    return typeof value === 'string';\n}\n\nfunction isNumber(value) {\n    return typeof value === 'number';\n}\n\nfunction isNumeric(value) {\n    return isNumber(value) || isString(value) && !isNaN(value - parseFloat(value));\n}\n\nfunction isEmpty(obj) {\n    return !(isArray(obj)\n        ? obj.length\n        : isObject(obj)\n            ? Object.keys(obj).length\n            : false\n    );\n}\n\nfunction isUndefined(value) {\n    return value === void 0;\n}\n\nfunction toBoolean(value) {\n    return isBoolean(value)\n        ? value\n        : value === 'true' || value === '1' || value === ''\n            ? true\n            : value === 'false' || value === '0'\n                ? false\n                : value;\n}\n\nfunction toNumber(value) {\n    const number = Number(value);\n    return !isNaN(number) ? number : false;\n}\n\nfunction toFloat(value) {\n    return parseFloat(value) || 0;\n}\n\nfunction toNode(element) {\n    return isNode(element) || isWindow(element) || isDocument(element)\n        ? element\n        : isNodeCollection(element) || isJQuery(element)\n            ? element[0]\n            : isArray(element)\n                ? toNode(element[0])\n                : null;\n}\n\nfunction toNodes(element) {\n    return isNode(element)\n        ? [element]\n        : isNodeCollection(element)\n            ? arrPrototype.slice.call(element)\n            : isArray(element)\n                ? element.map(toNode).filter(Boolean)\n                : isJQuery(element)\n                    ? element.toArray()\n                    : [];\n}\n\nfunction toList(value) {\n    return isArray(value)\n        ? value\n        : isString(value)\n            ? value.split(/,(?![^(]*\\))/).map(value => isNumeric(value)\n                ? toNumber(value)\n                : toBoolean(value.trim()))\n            : [value];\n}\n\nfunction toMs(time) {\n    return !time\n        ? 0\n        : endsWith(time, 'ms')\n            ? toFloat(time)\n            : toFloat(time) * 1000;\n}\n\nfunction isEqual(value, other) {\n    return value === other\n        || isObject(value)\n        && isObject(other)\n        && Object.keys(value).length === Object.keys(other).length\n        && each(value, (val, key) => val === other[key]);\n}\n\nfunction swap(value, a, b) {\n    return value.replace(new RegExp(`${a}|${b}`, 'mg'), match => {\n        return match === a ? b : a;\n    });\n}\n\nconst assign = Object.assign || function (target, ...args) {\n    target = Object(target);\n    for (let i = 0; i < args.length; i++) {\n        const source = args[i];\n        if (source !== null) {\n            for (const key in source) {\n                if (hasOwn(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n    }\n    return target;\n};\n\nfunction each(obj, cb) {\n    for (const key in obj) {\n        if (false === cb(obj[key], key)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction sortBy(array, prop) {\n    return array.sort(({[prop]: propA = 0}, {[prop]: propB = 0}) =>\n        propA > propB\n            ? 1\n            : propB > propA\n                ? -1\n                : 0\n    );\n}\n\nfunction uniqueBy(array, prop) {\n    const seen = new Set();\n    return array.filter(({[prop]: check}) => seen.has(check)\n        ? false\n        : seen.add(check) || true // IE 11 does not return the Set object\n    );\n}\n\nfunction clamp(number, min = 0, max = 1) {\n    return Math.min(Math.max(toNumber(number) || 0, min), max);\n}\n\nfunction noop() {}\n\nfunction intersectRect(r1, r2) {\n    return r1.left < r2.right &&\n        r1.right > r2.left &&\n        r1.top < r2.bottom &&\n        r1.bottom > r2.top;\n}\n\nfunction pointInRect(point, rect) {\n    return point.x <= rect.right &&\n        point.x >= rect.left &&\n        point.y <= rect.bottom &&\n        point.y >= rect.top;\n}\n\nconst Dimensions = {\n\n    ratio(dimensions, prop, value) {\n\n        const aProp = prop === 'width' ? 'height' : 'width';\n\n        return {\n            [aProp]: dimensions[prop] ? Math.round(value * dimensions[aProp] / dimensions[prop]) : dimensions[aProp],\n            [prop]: value\n        };\n    },\n\n    contain(dimensions, maxDimensions) {\n        dimensions = assign({}, dimensions);\n\n        each(dimensions, (_, prop) => dimensions = dimensions[prop] > maxDimensions[prop]\n            ? this.ratio(dimensions, prop, maxDimensions[prop])\n            : dimensions\n        );\n\n        return dimensions;\n    },\n\n    cover(dimensions, maxDimensions) {\n        dimensions = this.contain(dimensions, maxDimensions);\n\n        each(dimensions, (_, prop) => dimensions = dimensions[prop] < maxDimensions[prop]\n            ? this.ratio(dimensions, prop, maxDimensions[prop])\n            : dimensions\n        );\n\n        return dimensions;\n    }\n\n};\n\n\n//# sourceURL=webpack://UIkit/./src/util/lang.js?");

/***/ }),

/***/ "./src/util/promise.js":
/*!*****************************!*\
  !*** ./src/util/promise.js ***!
  \*****************************/
/*! exports provided: Promise, Deferred */
/*! ModuleConcatenation bailout: Module uses injected variables (setImmediate) */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(setImmediate) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Promise\", function() { return Promise; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Deferred\", function() { return Deferred; });\n/* harmony import */ var _lang__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lang */ \"./src/util/lang.js\");\n/* global setImmediate */\n\n\nconst Promise = 'Promise' in window ? window.Promise : PromiseFn;\n\nclass Deferred {\n    constructor() {\n        this.promise = new Promise((resolve, reject) => {\n            this.reject = reject;\n            this.resolve = resolve;\n        });\n    }\n}\n\n/**\n * Promises/A+ polyfill v1.1.4 (https://github.com/bramstein/promis)\n */\n\nconst RESOLVED = 0;\nconst REJECTED = 1;\nconst PENDING = 2;\n\nconst async = 'setImmediate' in window ? setImmediate : setTimeout;\n\nfunction PromiseFn(executor) {\n\n    this.state = PENDING;\n    this.value = undefined;\n    this.deferred = [];\n\n    const promise = this;\n\n    try {\n        executor(\n            x => {\n                promise.resolve(x);\n            },\n            r => {\n                promise.reject(r);\n            }\n        );\n    } catch (e) {\n        promise.reject(e);\n    }\n}\n\nPromiseFn.reject = function (r) {\n    return new PromiseFn((resolve, reject) => {\n        reject(r);\n    });\n};\n\nPromiseFn.resolve = function (x) {\n    return new PromiseFn((resolve, reject) => {\n        resolve(x);\n    });\n};\n\nPromiseFn.all = function all(iterable) {\n    return new PromiseFn((resolve, reject) => {\n        const result = [];\n        let count = 0;\n\n        if (iterable.length === 0) {\n            resolve(result);\n        }\n\n        function resolver(i) {\n            return function (x) {\n                result[i] = x;\n                count += 1;\n\n                if (count === iterable.length) {\n                    resolve(result);\n                }\n            };\n        }\n\n        for (let i = 0; i < iterable.length; i += 1) {\n            PromiseFn.resolve(iterable[i]).then(resolver(i), reject);\n        }\n    });\n};\n\nPromiseFn.race = function race(iterable) {\n    return new PromiseFn((resolve, reject) => {\n        for (let i = 0; i < iterable.length; i += 1) {\n            PromiseFn.resolve(iterable[i]).then(resolve, reject);\n        }\n    });\n};\n\nconst p = PromiseFn.prototype;\n\np.resolve = function resolve(x) {\n    const promise = this;\n\n    if (promise.state === PENDING) {\n        if (x === promise) {\n            throw new TypeError('Promise settled with itself.');\n        }\n\n        let called = false;\n\n        try {\n            const then = x && x.then;\n\n            if (x !== null && Object(_lang__WEBPACK_IMPORTED_MODULE_0__[\"isObject\"])(x) && Object(_lang__WEBPACK_IMPORTED_MODULE_0__[\"isFunction\"])(then)) {\n                then.call(\n                    x,\n                    x => {\n                        if (!called) {\n                            promise.resolve(x);\n                        }\n                        called = true;\n                    },\n                    r => {\n                        if (!called) {\n                            promise.reject(r);\n                        }\n                        called = true;\n                    }\n                );\n                return;\n            }\n        } catch (e) {\n            if (!called) {\n                promise.reject(e);\n            }\n            return;\n        }\n\n        promise.state = RESOLVED;\n        promise.value = x;\n        promise.notify();\n    }\n};\n\np.reject = function reject(reason) {\n    const promise = this;\n\n    if (promise.state === PENDING) {\n        if (reason === promise) {\n            throw new TypeError('Promise settled with itself.');\n        }\n\n        promise.state = REJECTED;\n        promise.value = reason;\n        promise.notify();\n    }\n};\n\np.notify = function notify() {\n    async(() => {\n        if (this.state !== PENDING) {\n            while (this.deferred.length) {\n                const [onResolved, onRejected, resolve, reject] = this.deferred.shift();\n\n                try {\n                    if (this.state === RESOLVED) {\n                        if (Object(_lang__WEBPACK_IMPORTED_MODULE_0__[\"isFunction\"])(onResolved)) {\n                            resolve(onResolved.call(undefined, this.value));\n                        } else {\n                            resolve(this.value);\n                        }\n                    } else if (this.state === REJECTED) {\n                        if (Object(_lang__WEBPACK_IMPORTED_MODULE_0__[\"isFunction\"])(onRejected)) {\n                            resolve(onRejected.call(undefined, this.value));\n                        } else {\n                            reject(this.value);\n                        }\n                    }\n                } catch (e) {\n                    reject(e);\n                }\n            }\n        }\n    });\n};\n\np.then = function then(onResolved, onRejected) {\n    return new PromiseFn((resolve, reject) => {\n        this.deferred.push([onResolved, onRejected, resolve, reject]);\n        this.notify();\n    });\n};\n\np.catch = function (onRejected) {\n    return this.then(undefined, onRejected);\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate))\n\n//# sourceURL=webpack://UIkit/./src/util/promise.js?");

/***/ })

/******/ })["default"];
});